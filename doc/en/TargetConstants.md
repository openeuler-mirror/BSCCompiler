### Introduction
This document describes the way to work with target constants in maple IR.
It's very important to distinguish `host` constants from the `target` ones.
`Host` constants represent values on the machine where the compiler runs.
`Target` constants represent values that will be present in the target code generated by the compiler.
So, in the common case there is no one-to-one mapping between `host` constants and `target` ones.
For example, a host machine has `one's complement` representation for integers, but the `target` machine
has `two's complement` integers representation. Or more realistic case when the target machine supports `int128_t` and can
hold 128-bit constants directly, but the `host` machine does not.
So, we need to find a safe and convenient way how to represent and operate on the `target` constants in maple IR
while compiling a user program.

### Working with constants in maple IR
Let's show how to work with constants on `Constant Folding` optimization as an example.
Consider the following Maple IR:
```
func &foo static used () i8 {
  return (add i8 (constval i8 1, constval i8 2))
}
```
we want to fold this `add` to perform calculation at compile time.
We could do something like this:
```c++
MIRConst *ConstantFold::FoldIntConstBinaryMIRConst(Opcode opcode, PrimType resultType,
                                                   const MIRIntConst *intConst0,
                                                   const MIRIntConst *intConst1) const {
  int64 intValueOfConst0 = intConst0->GetValue();
  int64 intValueOfConst1 = intConst1->GetValue();

  uint64 result64 = 0;
  uint32 result32 = 0;
  uint16 result16 = 0;
  uint8 result8 = 0;

  bool useResult64 = (GetPrimTypeSize(resultType) == 8);
  bool useResult32 = (GetPrimTypeSize(resultType) == 4);
  bool useResult16 = (GetPrimTypeSize(resultType) == 2);
  bool useResult8 = (GetPrimTypeSize(resultType) == 1);

  switch (opcode) {
    case OP_add: {
      if (useResult64) {
        result64 = static_cast<uint64>(intValueOfConst0) + static_cast<uint64>(intValueOfConst1);
      } else if (useResult32) {
        result32 = static_cast<uint32>(intValueOfConst0) + static_cast<uint32>(intValueOfConst1);
      } else if (useResult16) {
        result16 = static_cast<uint16>(intValueOfConst0) + static_cast<uint16>(intValueOfConst1);
      } else if (useResult8) {
        result8 = static_cast<uint8>(intValueOfConst0) + static_cast<uint8>(intValueOfConst1);
      }
      break;
    }
    ...
```
As can be seen, there is a lot of boilerplate code depending on the type size of the result of operation.
In a more general case, the sign of the result type is also has to be taken into account, doubling the code size (e.g. div)
Also, if we manipulate with 128-bit types it's possible that there is no `int128_t` type on the host machine and in this
case we need to perform such calculation manually. For example, we need to hold the value in two `int64_t` variables.
So, we need to be able to work with target constants in a safe and convenient way. To achieve this goal we can use
a special class that's called `IntVal`. It provides a convenient interface for manipulation with target constants.
For example, the above case can be managed as follows:
```c++
MIRConst *ConstantFold::FoldIntConstBinaryMIRConst(Opcode opcode, PrimType resultType,
                                                   const MIRIntConst *intConst0,
                                                   const MIRIntConst *intConst1) const {
  IntVal intVal0 = intConst0->GetValue();
  IntVal intVal1 = intConst1->GetValue();

  IntVal result(0, resultType);

  switch (opcode) {
    case OP_add: {
      result = intVal0.Add(intVal1, resultType);
      // or
      // result = intVal0 + intVal1;
      // if resultType is equal to type of operands
      break;
    }
    ...
```
Let's take a look at `IntVal` class in more detail.

##### The IntVal class
This class represents a target integer constant in `two's complement` representation.
It's able to hold signed and unsigned integers with arbitrary bit-width (currently, no more than 64 bits. 128-bit support is in progress)
that can be created using the following constructors:
```c++
/// Creates IntVal object from uint64 value with bit-width defined by bitWidth parameter
/// and interpreted as signed value if isSigned parameter is true
IntVal(uint64 val, uint8 bitWidth, bool isSigned);

/// The same as above, but bit-width and signedness are obtained from the given PrimType
IntVal(uint64 val, PrimType type);
```
Also, this class provides an interface to perform arithmetic, bitwise, comparison and other operations on the target constants.
For example:
```c++
/// perform an addition: *this + val. Bit-width and signedness of values must be the same
IntVal operator+(const IntVal &val) const;

/// the same as above, but performs '+' in terms of the given integer PrimType
IntVal Add(const IntVal &val, PrimType pType) const;

/// perform a binary 'and': *this & val. Bit-width and signedness of values must be the same
IntVal operator&(const IntVal &val) const;

/// the same as above, but performs '&' in terms of the given integer PrimType
IntVal And(const IntVal &val, PrimType pType) const;

/// perform a comparison: *this < val. Bit-width and signedness of values must be the same
bool operator<(const IntVal &rhs) const;

/// the same as above, but performs '<' in terms of the given integer PrimType
bool Less(const IntVal &rhs, PrimType pType) const;
```

There are `Extend`, `Trunc` and `TruncOrExtend` functions that allow truncating or extending (zero or sign extension)
depending on the given integer PrimType. These functions return new `IntVal` object that has bit-width and sign obtained
from the given PrimType and has a value obtained from the original value by truncation or extension (zero of sign).
```c++
IntVal TruncOrExtend(PrimType newType) cosnt;
IntVal Extend(PrimType newType) cosnt;
IntVal Trunc(PrimType newType) cosnt;
```
It's possible to get a host constant from the target one (in case the value can fit into the host constant) using the following
interfaces:
```c++
/// perform zero extension of the value
uint64 GetZXTValue(uint8 size = 0) const;

/// perform sign extension of the value
int64 GetSXTValue(uint8 size = 0) const;

/// perform sign or zero extension of the value depending on its sign
int64 GetExtValue(uint8 size = 0) const;
```
