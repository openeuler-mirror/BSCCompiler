#include "driver.h"
#include "parser.h"
#include "token.h"
#include "common_header_autogen.h"
#include "ruletable_util.h"

/////////////////////////////////////
// Testing autogen
/////////////////////////////////////

/*
// This is called by GetLiteral() which is generated by autogen
LiteralToken* Lexer::ProcessLiteralTokenText(LT_Type type, TokenText text) {
  LitData data;
  std::string value_text = StringVectorConsolidate(text);
  StringToValueImpl s2v;
  switch (type) {
  case LT_Int: {
    int i = s2v.StringToInt(value_text);
    data.mType = LT_Int;
    data.mData.mInt = i;
    break; }
  case LT_FP: {
    float f = s2v.StringToFloat(value_text);
    data.mType = LT_FP;
    data.mData.mFloat = f;
    break; }
  case LT_Bool: {
    bool b = s2v.StringToBool(value_text);
    data.mType = LT_Bool;
    data.mData.mBool = b;
    break; }
  case LT_Char: {
    char c = s2v.StringToChar(value_text);
    data.mType = LT_Char;
    data.mData.mChar = c;
    break; }
  case LT_String: {
    // add this string to the StringPool
    const char *addr = mStringPool.FindString(value_text);
    data.mType = LT_String;
    data.mData.mStr = addr;
    break; }
  case LT_Null: {
    bool b = s2v.StringToBool(value_text);
    data.mType = LT_FP;
    data.mData.mFloat = b;
    break; }
  case LT_NA:    // N/A,
  default:
    data.mType = LT_NA;
    break;
  }
  LiteralToken *lit = (LiteralToken*)mTokenPool.NewToken(sizeof(LiteralToken)); 
  new (lit) LiteralToken(data);

  return lit;
}
*/

// This is for testing autogen
Token* Lexer::LexToken_autogen(void) {
  SepId sep = GetSeparator(this);
  if (sep != SEP_NA) {
    SeparatorToken *t = (SeparatorToken*)mTokenPool.NewToken(sizeof(SeparatorToken)); 
    new (t) SeparatorToken(sep);
    return t;
  }

  OprId opr = GetOperator(this);
  if (opr != OPR_NA) {
    OperatorToken *t = (OperatorToken*)mTokenPool.NewToken(sizeof(OperatorToken)); 
    new (t) OperatorToken(opr);
    return t;
  }

  const char *keyword = GetKeyword(this);
  if (keyword != NULL) {
    KeywordToken *t = (KeywordToken*)mTokenPool.NewToken(sizeof(KeywordToken)); 
    new (t) KeywordToken(keyword);
    return t;
  }

  const char *identifier = GetIdentifier(this);
  if (identifier != NULL) {
    IdentifierToken *t = (IdentifierToken*)mTokenPool.NewToken(sizeof(IdentifierToken)); 
    new (t) IdentifierToken(identifier);
    return t;
  }

  LitData ld = GetLiteral(this);
  if (ld.mType != LT_NA) {
    LiteralToken *t = (LiteralToken*)mTokenPool.NewToken(sizeof(LiteralToken)); 
    new (t) LiteralToken(ld);
    return t;
  }

  return NULL;
}
//////////////////////////////////////////////////////////////////////////////////
//          Framework based on Autogen + Token
//////////////////////////////////////////////////////////////////////////////////

bool Parser::Parse_autogen() {
  if (GetVerbose() >= 1) {
    MMSG("\n\n>> Parsing .... ", filename);
  }

  // mLexer.ReadALine();
  // In Lexer::PrepareForFile() already did one ReadALine().

  while (!mLexer.EndOfFile()) {
    while (!mLexer.EndOfLine()) {
      Token* t = mLexer.LexToken_autogen();
      if (t)
        t->Dump();
      else
        return;
    }
    mLexer.ReadALine();
  }
} 

// return true : if successful
//       false : if failed
bool Parser::ParseStmt_autogen() {
}


int main (int argc, char *argv[]) {
  Parser *parser = new Parser(argv[1]);
  parser->Parse_autogen();
  delete parser;
  return 0;
}
