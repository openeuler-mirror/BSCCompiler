cscope 15 $HOME/OpenArkCompiler/src/MapleEng -q 0000001033 0000098472
	@lmbc/include/eng_shim.h

15 #ide
MPLENG_SHIM_H_


16 
	#MPLENG_SHIM_H_


	)

18 
	~<cdt
>

19 
	~"lmbc_g.h
"

21 
mea
 
	gm
 {

23 "C" 
t64_t
 
__geShim
(
LmbcFunc
*, ...);

	@lmbc/include/lmbc_eng.h

1 #ide
LMBC_ENG_H_


2 
	#LMBC_ENG_H_


	)

4 
	~<gnu/lib-mes.h
>

5 
	~<cdlib
>

6 
	~<ioam
>

7 
	~<fam
>

8 
	~"m_rr.h
"

9 
	~"b_mt.h
"

10 
	~"code_fo.h
"

11 
	~"m_funi.h
"

12 
	~"cڡtfd.h
"

13 
	~"m_ty.h
"

14 
	~"mvue.h
"

15 
	~"glob_bs.h
"

16 
	~"mfuni.h
"

18 
mea
 
	gm
 {

19 
ass
 
	gMFuni
;

20 
usg
 
	gLabM
 = 
d
::
unded_m
<
LabIdx
, 
	gStmtNode
*>;

23 
usg
 
	gVInf
 = 
PmInf
;

24 
	sPmInf
 {

25 
PrimTy
 
	gyp
;

26 
size_t
 
	gsize
;

27 
bo
 
	gisPg
;

28 
bo
 
	gisVg
;

29 
t32
 
	geIdx
;

34 
MIRSymb
 *
	gsym
;

35 
PUIdx
 
	gpuIdx
;

36 
PmInf
(
PrimTy
 
ty
, 
size_t
 
sz
, 
bo
 
ig
, 
t32_t
 
ageIdx
)

37 : 
yp
(
ty
), 
size
(
sz
), 
isPg
(
ig
), 
eIdx
(
ageIdx
) {}

38 
PmInf
(
PrimTy
 
ty
, 
size_t
 
sz
, 
bo
 
ig
, 
t32_t
 
ageIdx
, 
MIRSymb
 *
psym
)

39 : 
yp
(
ty
), 
size
(
sz
), 
isPg
(
ig
), 
eIdx
(
ageIdx
), 
sym
(
psym
) {}

40 
PmInf
(
PrimTy
 
ty
, 
size_t
 
sz
, 
bo
 
ig
, 
t32_t
 
ageIdx
, 
MIRSymb
 *
psym
, 
PUIdx
 
puidx
)

41 : 
yp
(
ty
), 
size
(
sz
), 
isPg
(
ig
), 
eIdx
(
ageIdx
), 
sym
(
psym
), 
puIdx
(
puidx
) {}

44 
ass
 
	gLmbcMod
;

45 as
	cLmbcFunc
 {

46 
	gpublic
:

47 
LmbcMod
 *
lmbcMod
;

48 
MIRFuni
 *
	gmFunc
;

49 
ut32
 
	gtSize
;

50 
ut32
 
	gameSize
;

51 
ut16
 
	gfmsNum
;

52 
ut32
 
	gfmsNumVs
;

53 
ut32
 
	gfmsAggSize
;

54 
ut32
 
	gfmsSize
;

55 
LabM
 
	gbM
;

56 
size_t
 
	gnumPgs
;

57 
bo
 
	gisVArgs
;

58 
	gd
::
ve
<
PmInf
*> 
pos2Pm
;

59 
	gd
::
unded_m
<
t32
, 
	gPmInf
*> 
	gidx2Pm
;

60 
SnFuncFms
();

61 
SnLabs
(
StmtNode
* 
mt
);

62 
SnPUStic
();

65 
usg
 
	gFuncM
 = 
d
::
unded_m
<
PUIdx
, 
	gLmbcFunc
*>;

67 as
	cFuncAddr
 {

68 
	gpublic
:

70 
LmbcFunc
 *
lmbcFunc
;

71 *
	gtiveFunc
;

72 } 
	gfuncP
;

73 
bo
 
	gisLmbcFunc
;

74 
ut32
 
	gfmsAggSize
;

75 
	gd
::
rg
 
funcName
;

76 
FuncAddr
(
bo
 
lmbcFunc
, *
func
, 
d
::
rg
 
funcName
, 
ut32
 
fmsAggSz
 = 0);

79 as
	cLmbcMod
 {

80 
	gpublic
:

81 
d
::
rg
 
lmbcPh
;

82 
MIRModu
* 
	gmMod
;

83 
FuncM
 
	gfuncM
;

84 
LmbcFunc
* 
	gmaFn
;

86 
	gd
::
unded_m
<
ut64
, 
	gVInf
*> 
	gglobAndSticVs
;

87 
	gd
::
unded_m
<
ut32
, std::
rg
> 
globSTbl
;

88 
	gglobSticMemSize
;

89 
ut8
* 
	gglobSticMem
;

90 
	gglobsSize
;

91 
ut8
* 
	gglobs
;

92 
ut32
 
	gaggrInOfft
;

93 
	gpublic
:

94 
InGlobVs
();

95 
InGlobVb
(
VInf
 *
pInf
);

96 
InICڡ
(
VInf
 *
pInf
, 
MIRICڡ
 &
tCڡ
, 
ut8
 *
d
);

97 
InSCڡ
(
VInf
* 
pInf
, 
MIRSCڡ
 &
mSCڡ
, 
ut8
 *
d
);

98 
InAddrofCڡ
(
VInf
 *
pInf
, 
MIRAddrofCڡ
 &
addrofCڡ
, 
ut8
 *
d
);

99 
InFltCڡ
(
VInf
 *
pInf
, 
MIRFltCڡ
 &
f32Cڡ
, 
ut8
 *
d
);

100 
InDoubCڡ
(
VInf
 *
Inf
, 
MIRDoubCڡ
 &
f64Cڡ
, 
ut8
 *
d
);

101 
InLblCڡ
(
VInf
 *
pInf
, 
MIRLblCڡ
 &
bCڡ
, 
ut8
 *
d
);

102 
InBFldCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
, 
t32_t
 &
locdBs
, 
bo
 &
fAlign
);

103 
ut8_t
* 
GGlobVInAddr
(
VInf
* 
pInf
, 
ut32
 
ign
);

104 
UpdeGlobVInAddr
(
VInf
* 
pInf
, 
ut32
 
size
);

105 
CheckUmedBFld
(
MIRSuTy
 &
Ty
, 
ut32
 &
evInFd
, ut32 
curFd
, 
t32
 &
locdBs
);

107 
LmbcMod
(* 
th
);

108 
MIRModu
* 
Impt
(
d
::
rg
 
th
);

109 
SnModu
();

110 
CcGlobVsSize
();

111 
LmbcFunc
* 
LkupLmbcFunc
(
PUIdx
 
puIdx
);

113 
	gd
::
ve
<*> 
libHds
;

114 
	gd
::
unded_m
<
PUIdx
, *>
	gextFuncM
;

115 
	gd
::
unded_m
<
ut32
, *>
	gextSymM
;

116 
LdDefLibs
();

117 * 
FdExtFunc
(
PUIdx
 
puidx
);

118 * 
FdExtSym
(
StIdx
 
idx
);

119 
AddGlobV
(
MIRSymb
 &
sym
, 
VInf
 *
pInf
);

120 
AddPUSticV
(
PUIdx
 
puIdx
, 
MIRSymb
 &
sym
, 
VInf
 *
pInf
);

121 
ut8
 *
GVAddr
(
StIdx
 
idx
);

122 
ut8
 *
GVAddr
(
PUIdx
 
puidx
, 
StIdx
 
idx
);

124 
InAggCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
);

125 
InAayCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
);

126 
InSrCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
);

127 
InPorCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
);

128 
	gd
::
unded_m
<
PUIdx
, 
	gFuncAddr
*> 
	gPUIdx2FuncAddr
;

129 
FuncAddr
* 
GFuncAddr
(
PUIdx
 
puIdx
);

	@lmbc/include/massert.h

16 #ide
MAPLERE_MASSERT_H_


17 
	#MAPLERE_MASSERT_H_


	)

19 
	~<cdio
>

20 
	~<cdlib
>

22 
	#MASSERT
(
cd
, 
fmt
, ...) \

24 i(!(
cd
)) { \

25 
	`rtf
(
dr
, 
__FILE__
 ":%d: As faed: " 
fmt
 "\n", 
__LINE__
, ##
__VA_ARGS__
); \

26 
	`abt
(); \

28 } 0)

	)

	@lmbc/include/mexpression.h

16 #ide
MAPLERE_MEXPRESSION_H_


17 
	#MAPLERE_MEXPRESSION_H_


	)

19 
	~<cdt
>

20 
	~"mas.h
"

22 
	#EXPRBINOP
(
ex
, 
s
, 
0
, 
1
, 
exPtyp
) \

24 
exPtyp
) { \

25 
PTY_i8
: 
s
.
x
.
i8
 = 
0
.x.i8 
ex
 
1
.x.i8; ; \

26 
PTY_i16
: 
s
.
x
.
i16
 = 
0
.x.i16 
ex
 
1
.x.i16; ; \

27 
PTY_i32
: 
s
.
x
.
i32
 = (
t64
)
0
.x.i32 
	`ex
 (t64)
1
.x.i32; ; \

28 
PTY_i64
: 
s
.
x
.
i64
 = 
0
.x.i64 
ex
 
1
.x.i64; ; \

29 
PTY_u8
: 
s
.
x
.
u8
 = 
0
.x.u8 
ex
 
1
.x.u8; ; \

30 
PTY_u16
: 
s
.
x
.
u16
 = 
0
.x.u16 
ex
 
1
.x.u16; ; \

31 
PTY_u32
: 
s
.
x
.
u32
 = 
0
.x.u32 
ex
 
1
.x.u32; ; \

32 
PTY_u64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

33 
PTY_a64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

34 
PTY_f32
: 
s
.
x
.
f32
 = 
0
.x.f32 
ex
 
1
.x.f32; ; \

35 
PTY_f64
: 
s
.
x
.
f64
 = 
0
.x.f64 
ex
 
1
.x.f64; ; \

36 : 
	`MIR_FATAL
("Unsu܋d PrimTy %d f by ot %s", 
exPtyp
, #exprop); \

38 
s
.
yp
 = 
ex
->ptyp; \

39 } 0)

	)

41 
	#EXPRCOMPOP
(
ex
,
s
, 
0
, 
1
, 
typ
, 
exyp
) \

44 
typ
) { \

45 
PTY_i8
: 
s
.
x
.
i64
 = 
0
.x.
i8
 
ex
 
1
.x.i8; ; \

46 
PTY_i16
: 
s
.
x
.
i64
 = 
0
.x.
i16
 
ex
 
1
.x.i16; ; \

47 
PTY_i32
: 
s
.
x
.
i64
 = 
0
.x.
i32
 
ex
 
1
.x.i32; ; \

48 
PTY_i64
: 
s
.
x
.
i64
 = 
0
.x.i64 
ex
 
1
.x.i64; ; \

49 
PTY_u8
: 
s
.
x
.
i64
 = 
0
.x.
u8
 
ex
 
1
.x.u8; ; \

50 
PTY_u16
: 
s
.
x
.
i64
 = 
0
.x.
u16
 
ex
 
1
.x.u16; ; \

51 
PTY_u32
: 
s
.
x
.
i64
 = 
0
.x.
u32
 
ex
 
1
.x.u32; ; \

52 
PTY_u64
: 
s
.
x
.
i64
 = 
0
.x.
u64
 
ex
 
1
.x.u64; ; \

53 
PTY_a64
: 
s
.
x
.
i64
 = 
0
.x.
a64
 
ex
 
1
.x.a64; ; \

54 
PTY_f32
: 
s
.
x
.
i64
 = 
0
.x.
f32
 
ex
 
1
.x.f32; ; \

55 
PTY_f64
: 
s
.
x
.
i64
 = 
0
.x.
f64
 
ex
 
1
.x.f64; ; \

56 : 
	`MIR_FATAL
("Unsu܋d ond PrimTy %d f comris ot %s", 
0
.
yp
, #exprop); \

58 
s
.
yp
 = 
exyp
; \

59 } 0)

	)

64 
	#EXPRCOMPOPNOFLOAT
(
ex
,
s
, 
0
, 
1
, 
typ
, 
exyp
) \

67 
typ
) { \

68 
PTY_i8
: 
s
.
x
.
i64
 = 
0
.x.
i8
 
ex
 
1
.x.i8; ; \

69 
PTY_i16
: 
s
.
x
.
i64
 = 
0
.x.
i16
 
ex
 
1
.x.i16; ; \

70 
PTY_i32
: 
s
.
x
.
i64
 = 
0
.x.
i32
 
ex
 
1
.x.i32; ; \

71 
PTY_i64
: 
s
.
x
.
i64
 = 
0
.x.i64 
ex
 
1
.x.i64; ; \

72 
PTY_u8
: 
s
.
x
.
i64
 = 
0
.x.
u8
 
ex
 
1
.x.u8; ; \

73 
PTY_u16
: 
s
.
x
.
i64
 = 
0
.x.
u16
 
ex
 
1
.x.u16; ; \

74 
PTY_u32
: 
s
.
x
.
i64
 = 
0
.x.
u32
 
ex
 
1
.x.u32; ; \

75 
PTY_u64
: 
s
.
x
.
i64
 = 
0
.x.
u64
 
ex
 
1
.x.u64; ; \

76 
PTY_a64
: 
s
.
x
.
i64
 = 
0
.x.
a64
 
ex
 
1
.x.a64; ; \

77 : 
	`MIR_FATAL
("Unsu܋d ond PrimTy %d f comris ot %s", 
0
.
yp
, #exprop); \

79 
s
.
yp
 = 
exyp
; \

80 } 0)

	)

82 
	#EXPRSELECTOP
(
s
, 
0
, 
l1
, 
l2
, 
exyp
) \

84 
MVue
 
1
, 
2
; \

85 
1
 = 
	`CvtTy
(
l1
, 
exyp
, s1.
yp
); \

86 
2
 = 
	`CvtTy
(
l2
, 
exyp
, s2.
yp
); \

87 
exyp
) { \

88 
PTY_i8
: 
s
.
x
.
i8
 = 
0
.x.
i64
? 
1
.x.i8 : 
2
.x.i8; ; \

89 
PTY_i16
: 
s
.
x
.
i16
 = 
0
.x.
i64
? 
1
.x.i16 : 
2
.x.i16; ; \

90 
PTY_i32
: 
s
.
x
.
i32
 = 
0
.x.
i64
? 
1
.x.i32 : 
2
.x.i32; ; \

91 
PTY_i64
: 
s
.
x
.
i64
 = 
0
.x.i64? 
1
.x.i64 : 
2
.x.i64; ; \

92 
PTY_u8
: 
s
.
x
.
u8
 = 
0
.x.
i64
? 
1
.x.u8 : 
2
.x.u8; ; \

93 
PTY_u16
: 
s
.
x
.
u16
 = 
0
.x.
i64
? 
1
.x.u16 : 
2
.x.u16; ; \

94 
PTY_u32
: 
s
.
x
.
u32
 = 
0
.x.
i64
? 
1
.x.u32 : 
2
.x.u32; ; \

95 
PTY_u64
: 
s
.
x
.
u64
 = 
0
.x.
i64
? 
1
.x.u64 : 
2
.x.u64; ; \

96 
PTY_a64
: 
s
.
x
.
a64
 = 
0
.x.
i64
? 
1
.x.a64 : 
2
.x.a64; ; \

97 
PTY_f32
: 
s
.
x
.
f32
 = 
0
.x.
i64
? 
1
.x.f32 : 
2
.x.f32; ; \

98 
PTY_f64
: 
s
.
x
.
f64
 = 
0
.x.
i64
? 
1
.x.f64 : 
2
.x.f64; ; \

99 : 
	`MIR_FATAL
("Unsu܋d PrimTy %d f se ot", 
exyp
); \

101 
s
.
yp
 = 
exyp
; \

102 } 0)

	)

104 
	#EXPRBININTOP
(
ex
, 
s
, 

, 
1
, 
exyp
) \

106 
MVue
 
0
 = 
	`CvtTy
(

, 
exyp
, op.
yp
); \

107 
exyp
) { \

108 
PTY_i8
: 
s
.
x
.
i8
 = 
0
.x.i8 
ex
 
1
.x.i8; ; \

109 
PTY_i16
: 
s
.
x
.
i16
 = 
0
.x.i16 
ex
 
1
.x.i16; ; \

110 
PTY_i32
: 
s
.
x
.
i32
 = 
0
.x.i32 
ex
 
1
.x.i32; ; \

111 
PTY_i64
: 
s
.
x
.
i64
 = 
0
.x.i64 
ex
 
1
.x.i64; ; \

112 
PTY_u8
: 
s
.
x
.
u8
 = 
0
.x.u8 
ex
 
1
.x.u8; ; \

113 
PTY_u16
: 
s
.
x
.
u16
 = 
0
.x.u16 
ex
 
1
.x.u16; ; \

114 
PTY_u32
: 
s
.
x
.
u32
 = 
0
.x.u32 
ex
 
1
.x.u32; ; \

115 
PTY_u64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

116 
PTY_a64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

117 : 
	`MIR_FATAL
("Unsu܋d PrimTy %d f ieg by ot %s", 
exyp
, #exprop); \

119 
s
.
yp
 = 
exyp
; \

120 } 0)

	)

123 
	#EXPRBININTOPUNSIGNED
(
ex
, 
s
, 
0
, 
1
, 
exyp
) \

125 
	`MASSERT
((
0
.
yp
 =
exyp
) || \

126 (
0
.
yp
 =
PTY_u32
 && 
exyp
 =
PTY_i32
) || \

127 (
0
.
yp
 =
PTY_i32
 && 
exyp
 =
PTY_u32
), \

128 "BINUINTOP Ty mismch: 0x%02xnd 0x%02x", 
0
.
yp
, 
exyp
); \

129 
1
.
yp
) { \

130 
PTY_i8
: \

131 
PTY_u8
: \

132 
	`MASSERT
(
1
.
x
.
u8
 <= 64, "OP_lshr shifting morehan 64 bites"); \

134 
PTY_i16
: \

135 
PTY_u16
: \

136 
	`MASSERT
(
1
.
x
.
u16
 <= 64, "OP_lshr shifting morehan 64 bites"); \

138 
PTY_i32
: \

139 
PTY_u32
: \

140 
	`MASSERT
(
1
.
x
.
u32
 <= 64, "OP_lshr shifting morehan 64 bites"); \

142 
PTY_i64
: \

143 
PTY_u64
: \

144 
PTY_a64
: \

145 
	`MASSERT
(
1
.
x
.
u64
 <= 64, "OP_lshr shifting morehan 64 bites"); \

148 
	`MIR_FATAL
("Unsu܋d PrimTy %d f unsigd ieg by ot %s", 
exyp
, #exprop); \

151 
exyp
) { \

152 
PTY_i8
: 
s
.
x
.
u8
 = 
0
.x.u8 
ex
 
1
.x.u8; ; \

153 
PTY_i16
: 
s
.
x
.
u16
 = 
0
.x.u16 
ex
 
1
.x.u16; ; \

154 
PTY_i32
: 
s
.
x
.
u32
 = 
0
.x.u32 
ex
 
1
.x.u32; ; \

155 
PTY_i64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

156 
PTY_a64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

157 
PTY_u8
: 
s
.
x
.
u8
 = 
0
.x.u8 
ex
 
1
.x.u8; ; \

158 
PTY_u16
: 
s
.
x
.
u16
 = 
0
.x.u16 
ex
 
1
.x.u16; ; \

159 
PTY_u32
: 
s
.
x
.
u32
 = 
0
.x.u32 
ex
 
1
.x.u32; ; \

160 
PTY_u64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

161 : 
	`MIR_FATAL
("Unsu܋d PrimTy %d f unsigd ieg by ot %s", 
exyp
, #exprop); \

163 
s
.
yp
 = 
exyp
; \

164 } 0)

	)

166 
	#EXPRMAXMINOP
(
ex
, 
s
, 
0
, 
1
, 
exyp
) \

168 
	`MASSERT
(
0
.
yp
 =
1
.ptyp, "MAXMINOP Type mismatch: 0x%02xnd 0x%02x", op0.ptyp, op1.ptyp); \

169 
	`MASSERT
(
0
.
yp
 =
exyp
, "MAXMINOP Type mismatch: 0x%02xnd 0x%02x", op0.ptyp,xprptyp); \

170 
exyp
) { \

171 
PTY_i8
: 
s
.
x
.
i8
 = 
0
.x.i8 
ex
 
1
.x.i8? op0.x.i8 : op1.x.i8; ; \

172 
PTY_i16
: 
s
.
x
.
i16
 = 
0
.x.i16 
ex
 
1
.x.i16? op0.x.i16 : op1.x.i16; ; \

173 
PTY_i32
: 
s
.
x
.
i32
 = 
0
.x.i32 
ex
 
1
.x.i32? op0.x.i32 : op1.x.i32; ; \

174 
PTY_i64
: 
s
.
x
.
i64
 = 
0
.x.i64 
ex
 
1
.x.i64? op0.x.i64 : op1.x.i64; ; \

175 
PTY_u8
: 
s
.
x
.
u8
 = 
0
.x.u8 
ex
 
1
.x.u8 ? op0.x.u8 : op1.x.u8; ; \

176 
PTY_u16
: 
s
.
x
.
u16
 = 
0
.x.u16 
ex
 
1
.x.u16? op0.x.u16 : op1.x.u16; ; \

177 
PTY_u32
: 
s
.
x
.
u32
 = 
0
.x.u32 
ex
 
1
.x.u32? op0.x.u32 : op1.x.u32; ; \

178 
PTY_u64
: 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64? op0.x.u64 : op1.x.u64; ; \

179 
PTY_a64
: 
s
.
x
.
a64
 = 
0
.x.a64 
ex
 
1
.x.a64? op0.x.a64 : op1.x.a64; ; \

180 
PTY_f32
: 
s
.
x
.
f32
 = 
0
.x.f32 
ex
 
1
.x.f32? op0.x.f32 : op1.x.f32; ; \

181 
PTY_f64
: 
s
.
x
.
f64
 = 
0
.x.f64 
ex
 
1
.x.f64? op0.x.f64 : op1.x.f64; ; \

182 : 
	`MIR_FATAL
("Unsu܋d PrimTy %d f by max/m ot %s", 
exyp
, #exprop); \

184 
s
.
yp
 = 
exyp
; \

185 } 0)

	)

187 
	#EXPRREMOP
(
ex
, 
s
, 
0
, 
1
, 
exyp
) \

189 
exyp
) { \

190 
PTY_i8
: if(
1
.
x
.
i8
 =0
s
.x.i8 = 0; \

191 if(
1
.
x
.
i8
 =-1 && 
0
.x.i8 =
INT8_MIN
) op0.x.i8 = 0; \

192 
s
.
x
.
i8
 = 
0
.x.i8 
ex
 
1
.x.i8; ; \

193 
PTY_i16
: if(
1
.
x
.
i16
 =0
s
.x.i16 = 0; \

194 if(
1
.
x
.
i16
 =-1 && 
0
.x.i16 =
INT16_MIN
) op0.x.i16 = 0; \

195 
s
.
x
.
i16
 = 
0
.x.i16 
ex
 
1
.x.i16; ; \

196 
PTY_i32
: if(
1
.
x
.
i32
 =0
s
.x.i32 = 0; \

197 if(
1
.
x
.
i32
 =-1 && 
0
.x.i32 =
INT32_MIN
) op0.x.i32 = 0; \

198 
s
.
x
.
i32
 = 
0
.x.i32 
ex
 
1
.x.i32; ; \

199 
PTY_i64
: if(
1
.
x
.
i64
 =0
s
.x.i64 = 0; \

200 if(
1
.
x
.
i64
 =-1 && 
0
.x.i64 =
INT64_MIN
) op0.x.i64 = 0; \

201 
s
.
x
.
i64
 = 
0
.x.i64 
ex
 
1
.x.i64; ; \

202 
PTY_u8
: if(
1
.
x
.
u8
 =0
s
.x.u8 = 0; \

203 
s
.
x
.
u8
 = 
0
.x.u8 
ex
 
1
.x.u8; ; \

204 
PTY_u16
: if(
1
.
x
.
u16
 =0
s
.x.u16 = 0; \

205 
s
.
x
.
u16
 = 
0
.x.u16 
ex
 
1
.x.u16; ; \

206 
PTY_u32
: if(
1
.
x
.
u32
 =0
s
.x.u32 = 0; \

207 
s
.
x
.
u32
 = 
0
.x.u32 
ex
 
1
.x.u32; ; \

208 
PTY_u64
: if(
1
.
x
.
u64
 =0
s
.x.u64 = 0; \

209 
s
.
x
.
u64
 = 
0
.x.u64 
ex
 
1
.x.u64; ; \

210 : 
	`MIR_FATAL
("Unsu܋d PrimTy %d f܄em ot %s", 
exyp
, #exprop); \

212 
s
.
yp
 = 
exyp
; \

213 } 0)

	)

215 
	#EXPRUNROP
(
ex
, 
s
, 
0
, 
exyp
) \

217 
	`MASSERT
(
0
.
yp
 =
exyp
 || \

218 ((
0
.
yp
 =
PTY_i32
 || op0.y=
PTY_u32
) && \

219 (
exyp
 =
PTY_i32
 ||xy=
PTY_u32
), "UNROP Ty mismch: 0x%02xnd 0x%02x", 
0
.
yp
,xprptyp); \

220 
exyp
) { \

221 
PTY_i8
: 
s
.
x
.
i8
 = 
ex
 
0
.x.i8; ; \

222 
PTY_i16
: 
s
.
x
.
i16
 = 
ex
 
0
.x.i16; ; \

223 
PTY_i32
: 
s
.
x
.
i32
 = 
ex
 
0
.x.i32; ; \

224 
PTY_i64
: 
s
.
x
.
i64
 = 
ex
 
0
.x.i64; ; \

225 
PTY_u8
: 
s
.
x
.
u8
 = 
ex
 
0
.x.u8; ; \

226 
PTY_u16
: 
s
.
x
.
u16
 = 
ex
 
0
.x.u16; ; \

227 
PTY_u32
: 
s
.
x
.
u32
 = 
ex
 
0
.x.u32; ; \

228 
PTY_u64
: 
s
.
x
.
u64
 = 
ex
 
0
.x.u64; ; \

229 : 
	`MIR_FATAL
("Unsu܋d PrimTy %d f ury ot %s", 
exyp
, #exprop); \

231 
s
.
yp
 = 
exyp
; \

232 } 0)

	)

	@lmbc/include/mfunction.h

16 #ide
MAPLERE_MFUNCTION_H_


17 
	#MAPLERE_MFUNCTION_H_


	)

19 
	~<ve
>

20 
	~<dlf.h
>

22 
	~<unid.h
>

23 
	~<sys/sys.h
>

24 
	#gtid
(
	`sys
(
SYS_gtid
)

	)

26 
	~"m_nodes.h
"

27 
	~"mvue.h
"

28 
	~"lmbc_g.h
"

30 
	#VARNAMELENGTH
 16

	)

31 
	#ALLOCA_MEMMAX
 0x4000

	)

33 
mea
 
	gm
 {

35 
ass
 
	gLmbcMod
;

36 
ass
 
	gLmbcFunc
;

37 
	gPmInf
;

40 
usg
 
	gffi__t
 = (*)();

51 
ut
 
	ggp_offt
;

52 
ut
 
	g_offt
;

53 *
	govow_g_
;

54 *
	gg_ve_
;

55 } 
	tVaLiX86_64
[1];

58 *
	gack
;

59 *
	ggr_t
;

60 *
	gvr_t
;

61 
	ggr_offs
;

62 
	gvr_offs
;

63 } 
	tVaLiAch64
;

65 
usg
 
	gVaLi
 = 
VaLiAch64
;

68 as
	cMFuni
 {

69 
	gpublic
:

71 
LmbcFunc
* 
fo
;

72 
MFuni
* 
	gΔ
;

73 
StmtNode
* 
	gxtStmt
;

74 
ut8
* 
	game
;

75 
ut8
* 
	g
;

76 
ut8
* 
	gloMem
;

77 
ut32
 
	gloOfft
;

78 
MVue
* 
	gpRegs
;

79 
MVue
* 
	gfmVs
;

82 
ut16
 
	gnumClArgs
;

83 
MVue
* 
	gArgs
;

84 
ut8
* 
	gaggrArgsBuf
;

85 
ut8
* 
	gvArgsBuf
;

86 
MVue
 
	gtV0
;

87 
MVue
 
	gtV1
;

88 
ut8
* 
	gvaArgs
;

89 
ut32
 
	gvaArgsSize
;

91 
exic
 
MFuni
(
LmbcFunc
 *
funcInfo
,

92 
MFuni
 *
funcCr
,

93 
ut8
 *
autoVs
,

94 
MVue
 *
pRegs
,

95 
MVue
 *
fmVs
);

96 ~
MFuni
();

97 
ut8
 *
Ao
(
ut32
 
size
);

98 
ut8
 *
GFmVAddr
(
StIdx
 
idx
);

99 
ClMFuncDe
(
ClNode
 *

);

100 
ClMFuncInde
(
INode
 *
i
, 
LmbcFunc
 *
Info
);

101 
ClExtFuncDe
(
ClNode
* 

);

102 
ClExtFuncInde
(
INode
 *
iδo
, * 

);

103 
ClVaArgFunc
(
numArgs
, 
LmbcFunc
 *
Info
);

104 
ClWhFFI
(
PrimTy
 
t_yp
, 
ffi__t
 

);

105 
ClIrsic
(
IrsicNode
 &
n
);

108 
bo
 
IsExtFunc
(
PUIdx
 
puIdx
, 
LmbcMod
 &
modu
);

109 
MVue
 
InvokeFunc
(
LmbcFunc
* 

, 
MFuni
 *
Δ
);

110 
MVue
 
EvEx
(
MFuni
 &
func
, 
BaNode
* 
ex
, 
PmInf
 *
rm
 = 
nuαr
);

111 
me
(
ut8
* 
addr
, 
PrimTy
 
yp
, 
MVue
& 
v
, 
bo
 
toVArgSck
);

	@lmbc/include/mprimtype.h

16 #ide
MAPLERE_MPRIMTYPE_H_


17 
	#MAPLERE_MPRIMTYPE_H_


	)

26 
	#PTYSIZE_Invid
 0

	)

27 
	#PTYSIZE_void
 0

	)

28 
	#PTYSIZE_i8
 1

	)

29 
	#PTYSIZE_i16
 2

	)

30 
	#PTYSIZE_i32
 3

	)

31 
	#PTYSIZE_i64
 4

	)

32 
	#PTYSIZE_u8
 1

	)

33 
	#PTYSIZE_u16
 2

	)

34 
	#PTYSIZE_u32
 3

	)

35 
	#PTYSIZE_u64
 4

	)

36 
	#PTYSIZE_u1
 1

	)

37 
	#PTYSIZE_r
 3

	)

38 
	#PTYSIZE_f
 3

	)

39 
	#PTYSIZE_a32
 3

	)

40 
	#PTYSIZE_a64
 4

	)

41 
	#PTYSIZE_f32
 3

	)

42 
	#PTYSIZE_f64
 4

	)

43 
	#PTYSIZE_f128
 5

	)

44 
	#PTYSIZE_c64
 5

	)

45 
	#PTYSIZE_c128
 6

	)

46 
	#PTYSIZE_simer
 3

	)

47 
	#PTYSIZE_simeobj
 3

	)

48 
	#PTYSIZE_dyny
 4

	)

49 
	#PTYSIZE_dynundef
 4

	)

50 
	#PTYSIZE_dyu
 4

	)

51 
	#PTYSIZE_dynbo
 4

	)

52 
	#PTYSIZE_dyni32
 4

	)

53 
	#PTYSIZE_dynr
 4

	)

54 
	#PTYSIZE_dynobj
 4

	)

55 
	#PTYSIZE_dynf64
 4

	)

56 
	#PTYSIZE_dynf32
 4

	)

57 
	#PTYSIZE_dye
 4

	)

58 
	#PTYSIZE_cڡS
 0

	)

59 
	#PTYSIZE_g
 0

	)

60 
	#PTYSIZE_agg
 0

	)

61 
	#PTYSIZE_v2i64
 0

	)

62 
	#PTYSIZE_v4i32
 0

	)

63 
	#PTYSIZE_v8i16
 0

	)

64 
	#PTYSIZE_v16i8
 0

	)

65 
	#PTYSIZE_v2f64
 0

	)

66 
	#PTYSIZE_v4f32
 0

	)

67 
	#PTYSIZE_unknown
 0

	)

68 
	#PTYSIZE_Dived
 0

	)

71 
	#FFITYPE_Invid
 
ffi_ty_void


	)

72 
	#FFITYPE_void
 
ffi_ty_void


	)

73 
	#FFITYPE_i8
 
ffi_ty_st8


	)

74 
	#FFITYPE_i16
 
ffi_ty_st16


	)

75 
	#FFITYPE_i32
 
ffi_ty_st32


	)

76 
	#FFITYPE_i64
 
ffi_ty_st64


	)

77 
	#FFITYPE_u8
 
ffi_ty_ut8


	)

78 
	#FFITYPE_u16
 
ffi_ty_ut16


	)

79 
	#FFITYPE_u32
 
ffi_ty_ut32


	)

80 
	#FFITYPE_u64
 
ffi_ty_ut64


	)

81 
	#FFITYPE_u1
 
ffi_ty_ut8


	)

82 
	#FFITYPE_r
 
ffi_ty_por


	)

83 
	#FFITYPE_f
 
ffi_ty_por


	)

84 
	#FFITYPE_a32
 
ffi_ty_por


	)

85 
	#FFITYPE_a64
 
ffi_ty_por


	)

86 
	#FFITYPE_f32
 
ffi_ty_t


	)

87 
	#FFITYPE_f64
 
ffi_ty_doub


	)

88 
	#FFITYPE_f128
 
ffi_ty_void


	)

89 
	#FFITYPE_c64
 
ffi_ty_void


	)

90 
	#FFITYPE_c128
 
ffi_ty_void


	)

91 
	#FFITYPE_simer
 
ffi_ty_void


	)

92 
	#FFITYPE_simeobj
 
ffi_ty_void


	)

93 
	#FFITYPE_dyny
 
ffi_ty_void


	)

94 
	#FFITYPE_dynundef
 
ffi_ty_void


	)

95 
	#FFITYPE_dyu
 
ffi_ty_void


	)

96 
	#FFITYPE_dynbo
 
ffi_ty_void


	)

97 
	#FFITYPE_dyni32
 
ffi_ty_void


	)

98 
	#FFITYPE_dynr
 
ffi_ty_void


	)

99 
	#FFITYPE_dynobj
 
ffi_ty_void


	)

100 
	#FFITYPE_dynf64
 
ffi_ty_void


	)

101 
	#FFITYPE_dynf32
 
ffi_ty_void


	)

102 
	#FFITYPE_dye
 
ffi_ty_void


	)

103 
	#FFITYPE_cڡS
 
ffi_ty_void


	)

104 
	#FFITYPE_g
 
ffi_ty_void


	)

105 
	#FFITYPE_agg
 
ffi_ty_void


	)

106 
	#FFITYPE_v2i64
 
ffi_ty_void


	)

107 
	#FFITYPE_v4i32
 
ffi_ty_void


	)

108 
	#FFITYPE_v8i16
 
ffi_ty_void


	)

109 
	#FFITYPE_v16i8
 
ffi_ty_void


	)

110 
	#FFITYPE_v2f64
 
ffi_ty_void


	)

111 
	#FFITYPE_v4f32
 
ffi_ty_void


	)

112 
	#FFITYPE_unknown
 
ffi_ty_void


	)

113 
	#FFITYPE_Dived
 
ffi_ty_void


	)

114 
	#FFITYPE_i128
 
ffi_ty_void


	)

115 
	#FFITYPE_u128
 
ffi_ty_void


	)

116 
	#FFITYPE_v2u64
 
ffi_ty_void


	)

117 
	#FFITYPE_v4u32
 
ffi_ty_void


	)

118 
	#FFITYPE_v8u16
 
ffi_ty_void


	)

119 
	#FFITYPE_v16u8
 
ffi_ty_void


	)

120 
	#FFITYPE_v2i32
 
ffi_ty_void


	)

121 
	#FFITYPE_v4i16
 
ffi_ty_void


	)

122 
	#FFITYPE_v8i8
 
ffi_ty_void


	)

123 
	#FFITYPE_v2u32
 
ffi_ty_void


	)

124 
	#FFITYPE_v4u16
 
ffi_ty_void


	)

125 
	#FFITYPE_v8u8
 
ffi_ty_void


	)

126 
	#FFITYPE_v2f32
 
ffi_ty_void


	)

127 
	#FFITYPE_rvedy1
 
ffi_ty_void


	)

128 
	#FFITYPE_rvedy2
 
ffi_ty_void


	)

129 
	#FFITYPE_rvedy3
 
ffi_ty_void


	)

130 
	#FFITYPE_rvedy4
 
ffi_ty_void


	)

131 
	#FFITYPE_rvedy5
 
ffi_ty_void


	)

132 
	#FFITYPE_rvedy6
 
ffi_ty_void


	)

133 
	#FFITYPE_rvedy7
 
ffi_ty_void


	)

134 
	#FFITYPE_rvedy8
 
ffi_ty_void


	)

135 
	#FFITYPE_rvedy9
 
ffi_ty_void


	)

136 
	#FFITYPE_rvedy10
 
ffi_ty_void


	)

	@lmbc/include/mvalue.h

16 #ide
MAPLERE_MVALUE_H_


17 
	#MAPLERE_MVALUE_H_


	)

19 
	~<cdt
>

20 
	~"im_tys.h
"

22 
mea
 
	gm
 {

23 
	sMVue
 {

25 
t8
 
	gi8
;

26 
t16
 
	gi16
;

27 
t32
 
	gi32
;

28 
t64
 
	gi64
;

29 
ut8
 
	gu8
;

30 
ut16
 
	gu16
;

31 
ut32
 
	gu32
;

32 
ut64
 
	gu64
;

33 
	gf32
;

34 
	gf64
;

35 
ut8
 *
	ga64
;

36 *
	gr
;

37 *
	gr
;

38 } 
	gx
;

39 
PrimTy
 
	gyp
:8;

40 
size_t
 
	gaggSize
;

	@lmbc/src/eng_shim.cpp

15 
	~"mfuni.h
"

16 
	~"mas.h
"

17 
	~"lmbc_g.h
"

19 
mea
 
	gm
 {

21 "C" 
t64


22 
__geShim
(
LmbcFunc
* 

, ...) {

23 
ut8
 
ame
[

->
ameSize
];

24 
MVue
 
egs
[

->
numPgs
];

25 
MVue
 
fmVs
[

->
fmsNumVs
+1];

26 
MFuni
 
shim_Δ
(

, 
nuαr
, 
ame
, 
egs
, 
fmVs
);

28 
MVue
 
v
;

29 i(

->
fmsNum
 > 0) {

30 
MVue
 
Args
[

->
fmsNum
];

31 
va_li
 
gs
;

32 
va_t
 (
gs
, 

);

34 
gIdx
 = 0;

35 
gIdx
 < 

->
fmsNum
) {

37 
v
.
yp
 = 

->
pos2Pm
[
gIdx
]->ptyp;

38 
v
.
yp
) {

39 
PTY_i8
:

40 
v
.
x
.
i8
 = 
va_g
(
gs
, );

42 
PTY_i16
:

43 
v
.
x
.
i16
 = 
va_g
(
gs
, );

45 
PTY_i32
:

46 
v
.
x
.
i32
 = 
va_g
(
gs
, );

48 
PTY_i64
:

49 
v
.
x
.
i64
 = 
va_g
(
gs
, );

51 
PTY_u16
:

52 
v
.
x
.
u16
 = 
va_g
(
gs
, );

54 
PTY_a64
:

55 
v
.
x
.
a64
 = 
va_g
(
gs
, 
ut8
*);

57 
PTY_f32
:

59 
PTY_f64
:

60 
v
.
x
.
f64
 = 
va_g
(
gs
, );

63 
MIR_FATAL
("Unsu܋d PrimTy %d", 
v
.
yp
);

65 
Args
[
gIdx
] = 
v
;

66 ++
gIdx
;

68 
shim_Δ
.
numClArgs
 = 

->
fmsNum
;

69 
shim_Δ
.
Args
 = callArgs;

71 
v
 = 
InvokeFunc
(

, &
shim_Δ
);

	@lmbc/src/init.cpp

15 
	~"mas.h
"

16 
	~"lmbc_g.h
"

17 
	~"g_shim.h
"

19 
mea
 
	gm
 {

22 
	#ROUNDUP8
(
v
(((v+7)>>3)<<3)

	)

25 
le
 
AlignOfft
(
ut32
 &
offt
, ut32 
ign
) {

26 
	gofft
 = (
offt
 + 
ign
-1) & ~(align-1);

29 
	gLmbcFunc
::
LmbcFunc
(
LmbcMod
 *
mod
, 
MIRFuni
 *
func
: 
lmbcMod
(mod), 
mFunc
(func) {

30 
	gameSize
 = 
ROUNDUP8
(
func
->
GFmeSize
());

31 
	gisVArgs
 = 
func
->
GMIRFuncTy
()->
IsVgs
();

32 
	gnumPgs
 = 
func
->
GPgTab
()->
Size
();

35 
	gLmbcMod
::
InModu
() {

36 
CcGlobAndSticVSize
();

37 
MIRFuni
 *
	gmFunc
 : 
mMod
->
GFuniLi
()) {

38 iut
node
 = 
mFunc
->
GBody
()) {

39 
LmbcFunc
* 

 = 
w
 LmbcFunc(
this
, 
mFunc
);

40 
ASSERT
(

, "Create Lmbc function failed");

41 
	g
->
SnFms
();

42 
	g
->
SnLabs
(
node
);

43 
	gfuncM
[
mFunc
->
GPuidx
()] = 

;

44 i(
	gmFunc
->
GName
().
com
("main") == 0) {

45 
maFn
 = 

;

50 
InGlobVs
();

53 
	gLmbcFunc
::
SnFms
() {

54 
MVe
<
FmDef
> 
fmDefVec
 = 
mFunc
->
GFmDefVec
();

55 
	gfmsNum
 = 
fmDefVec
.
size
();

56 
	gfmsSize
 = 0;

57 
	gfmsNumVs
 = 0;

58 
	gfmsAggSize
 = 0;

59 
MASSERT
(
mFunc
->
GRuTy
(!
nuαr
, "mirFunceturnype isull");

60 
	gtSize
 = 
mFunc
->
GRuTy
()->
GSize
();

61 
ut32
 
	gi
 = 0; i < 
	gfmDefVec
.
size
(); i++) {

62 
MIRSymb
* 
	gsymb
 = 
fmDefVec
[
i
].
fmSym
;

63 
MIRTy
* 
	gty
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
fmDefVec
[
i
].
fmTyIdx
);

64 
bo
 
	gisPg
 = (
symb
->
GSKd
(=
kStPg
);

65 
t32
 
	gageIdx
;

66 i(
	gty
->
GPrimTy
(=
PTY_agg
) {

67 
ageIdx
 = 
fmsAggSize
;

68 
	gfmsAggSize
 +
ty
->
GSize
();

70 
	gageIdx
 = 
isPg
? 
symb
->
GPg
()->
GPgNo
(): ++
fmsNumVs
;

73 
PmInf
* 
	gpInf
 = 
w
 PmInf(
ty
->
GPrimTy
(),y->
GSize
(), 
isPg
, 
ageIdx
);

74 
	gidx2Pm
[
symb
->
GStIdx
().
FuIdx
()] = 
pInf
;

75 
	gpos2Pm
.
push_back
(
pInf
);

76 
	gfmsSize
 +
ty
->
GSize
();

80 
	gLmbcFunc
::
SnLabs
(
StmtNode
* 
mt
) {

81 
mt
 !
nuαr
) {

82 
mt
->

) {

83 
OP_block
:

84 
mt
 = 
ic_
<
BlockNode
*>(mt)->
GF
();

85 
SnLabs
(
mt
);

87 
	gOP_b
:

88 
bM
[
ic_
<
LabNode
*>(
mt
)->
GLabIdx
()] = stmt;

93 
	gmt

mt
->
GNext
();

108 
ut32
 
CheckFxAayMemb
(
MIRSymb
 &
sym
, 
MIRTy
 &
ty
) {

109 aut&
	gTy
 = 
ic_
<
MIRSuTy
&>(
ty
);

110 aut&
	gCڡ
 = 
ic_
<
MIRAggCڡ
&>(*
sym
.
GKڡ
());

111 
TyIdxFldArPa
 
	gtp
 = 
Ty
.
GTyidxFldArPa
(Ty.
GFldsSize
()-1);

112 
MIRTy
 *
	gϡFdTy
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
tp
.
f
);

113 i(
	gϡFdTy
->
GKd
(=
kTyAay
 &&

114 
ic_
<
MIRAayTy
*>(
ϡFdTy
)->
GSizeAayIm
(0) == 1 &&

115 
Cڡ
.
GCڡVec
().
size
(=
Ty
.
GFldsSize
()) {

116 
MIRCڡ
 &
emCڡ
 = *
Cڡ
.
GCڡVecIm
(Cڡ.
GCڡVec
().
size
()-1);

117 
MASSERT
(
emCڡ
.
GTy
().
GKd
(=
kTyAay
, "array initializerxpected");

118 aut&
	grCt
 = 
ic_
<
MIRAggCڡ
&>(
emCڡ
);

119 i(
	grCt
.
GCڡVec
().
size
() > 1) {

120  (
	grCt
.
GCڡVec
().
size
()-1* 
	gemCڡ
.
GTy
().
GSize
();

127 
	gLmbcMod
::
CcGlobAndSticVSize
() {

128 
ut32
 
offt
 = 0;

130 
size_t
 
	gi
 = 0; i < 
	gGlobTabs
::
GGsymTab
().
GSymbTabSize
(); ++i) {

131 
MIRSymb
 *
	gsym
 = 
GlobTabs
::
GGsymTab
().
GSymbFromStidx
(
i
);

132 i(!
	gsym
 ||

133 !(
	gsym
->
GSKd
(=
kStV
) ||

134 !(
sym
->
GStageCss
(=
kScGlob
 || sym->GStageCss(=
kScFic
)) {

137 i(
MIRTy
 *
	gty
 = 
sym
->
GTy
()) {

138 
AlignOfft
(
offt
, 
ty
->
GAlign
());

139 
VInf
* 
	gpInf
 = 
w
 VInf(
ty
->
GPrimTy
(),y->
GSize
(), 
l
, 
offt
, 
sym
);

140 
AddGlobV
(*
sym
, 
pInf
);

141 
	gofft
 +
ty
->
GSize
();

142 i(
	gty
->
GKd
(=
kTySu
) {

143 
offt
 +
CheckFxAayMemb
(*
sym
, *
ty
);

147 
	gglobsSize
 = 
offt
;

149 
MIRFuni
 *
	gfunc
 : 
mMod
->
GFuniLi
()) {

150 iut
node
 = 
func
->
GBody
()) {

151 
SnPUStic
(
func
);

156 
	gLmbcMod
::
SnPUStic
(
MIRFuni
 *
func
) {

157 
size_t
 
size
 = 
func
->
GSymbTabSize
();

158 
size_t
 
	gi
 = 0; i < 
	gsize
; ++i) {

159 
MIRSymb
 *
	gsym
 = 
func
->
GSymbTabIm
(
i
);

160 i(!
	gsym
 || !sym->
IsPUStic
(|| !sym->
IsCڡ
()) {

163 i(
MIRTy
 *
	gty
 = 
sym
->
GTy
()) {

164 
VInf
* 
pInf
 = 
w
 VInf(
ty
->
GPrimTy
(),y->
GSize
(), 
l
, 
globsSize
, 
sym
, 
func
->
GPuidx
());

165 
AddPUSticV
(
func
->
GPuidx
(), *
sym
, 
pInf
);

166 
	gglobsSize
 +
ty
->
GSize
();

176 
ut8
 *
	gLmbcMod
::
GGlobVInAddr
(
VInf
* 
pInf
, 
ut32
 
ign
) {

177 i(
	gpInf
->
	gyp
 !
PTY_agg
) {

178  
globs
 + 
pInf
->
eIdx
;

180 
AlignOfft
(
aggrInOfft
, 
ign
);

181  
	gglobs
 + 
	gpInf
->
	geIdx
 + 
	gaggrInOfft
;

184 
le
 
	gLmbcMod
::
UpdeGlobVInAddr
(
VInf
* 
pInf
, 
ut32
 
size
) {

185 i(
	gpInf
->
	gyp
 =
PTY_agg
) {

186 
aggrInOfft
 +
size
;

194 
	gLmbcMod
::
CheckUmedBFld
(
MIRSuTy
 &
Ty
, 
ut32
 &
evInFd
, ut32 
curFd
, 
t32
 &
locdBs
) {

196 i(
	gcurFd
 - 1 =
evInFd
) {

197 
evInFd
 = 
curFd
;

201 aut
	gi
 = 
evInFd
; i < 
	gcurFd
 -1; ++i) {

202 
TyIdxFldArPa
 
	gtp
 = 
Ty
.
GTyidxFldArPa
(
i
);

203 
MIRTy
 *
	gty
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
tp
.
f
);

206 i(
	gty
->
GKd
(!
kTyBFld
) {

209 
MASSERT
(
ty
->
GKd
()==
kTyBFld
, "Un-named bitfieldxpected");

210 
ut8
 
	gbFdWidth
 = 
ic_
<
MIRBFldTy
*>(
ty
)->
GFldSize
();

211 
ut32
 
	gbaFdSz
 = 
GPrimTySize
(
ty
->
GPrimTy
());

213 
ut32
 
	gign
 = 
locdBs
 ? 1 : 
baFdSz
;

214 
AlignOfft
(
aggrInOfft
, 
ign
);

216 i(
	glocdBs
 + 
	gbFdWidth
 > (
	gbaFdSz
 * 8)) {

217 
	gaggrInOfft
+
baFdSz
;

218 
	glocdBs
 = 
bFdWidth
;

220 
	glocdBs
 +
bFdWidth
;

223 
	gevInFd
 = 
curFd
;

226 
	gLmbcMod
::
InSCڡ
(
VInf
* 
pInf
, 
MIRSCڡ
 &
mSCڡ
, 
ut8
* 
d
) {

227 
USIdx
 
	gurIdx
 = 
mSCڡ
.
GVue
();

228 aut
	g
 = 
globSTbl
.

(

229 
d
::

<
ut32
, std::
rg
>(
urIdx
, 
GlobTabs
::
GUSTab
().
GSgFromSIdx
(ustrIdx)));

230 *(cڡ **)
	gd
 = 

.
f
->
cd
.
c_r
();

233 
le
 
	gLmbcMod
::
InFltCڡ
(
VInf
 *
pInf
, 
MIRFltCڡ
 &
f32Cڡ
, 
ut8
* 
d
) {

234 *(*)
	gd
 = 
f32Cڡ
.
GVue
();

237 
le
 
	gLmbcMod
::
InDoubCڡ
(
VInf
 *
pInf
, 
MIRDoubCڡ
 &
f64Cڡ
, 
ut8
* 
d
) {

238 *(*)
	gd
 = 
f64Cڡ
.
GVue
();

241 
	gLmbcMod
::
InLblCڡ
(
VInf
 *
pInf
, 
MIRLblCڡ
 &
bCڡ
, 
ut8
 *
d
) {

242 
LabIdx
 
	gbIdx
 = 
bCڡ
.
GVue
();

243 
LmbcFunc
 *
	g
 = 
LkupLmbcFunc
(
bCڡ
.
GPUIdx
());

244 
StmtNode
* 
	gb
 = 

->
bM
[
bIdx
];

245 
MASSERT
(
b
, "InitLblConstabelot foound");

246 *(
	gStmtNode
 **)
	gd
 = 
b
;

249 
	gLmbcMod
::
InICڡ
(
VInf
* 
pInf
, 
MIRICڡ
 &
tCڡ
, 
ut8
* 
d
) {

250 
t64
 
	gv
 = 
tCڡ
.
GExtVue
();

251 
	gtCڡ
.
GTy
().
GPrimTy
()) {

252 
	gPTY_i64
:

253 *(
t64
*)
d
 = (t64)
v
;

255 
	gPTY_i32
:

256 *(
t32
*)
d
 = (t32)
v
;

258 
	gPTY_i16
:

259 *(
t16
*)
d
 = (t16)
v
;

261 
	gPTY_i8
:

262 *(
t8
*)
d
 = (t8)
v
;

264 
	gPTY_u64
:

265 *(
ut64
*)
d
 = (ut64)
v
;

267 
	gPTY_u32
:

268 *(
ut32
*)
d
 = (ut32)
v
;

270 
	gPTY_u16
:

271 *(
ut16
*)
d
 = (ut16)
v
;

273 
	gPTY_u8
:

274 *(
ut8
*)
d
 = (ut8)
v
;

281 
	gLmbcMod
::
InPorCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
) {

282 
ut8
 *
	gd
 = 
GGlobVInAddr
(
pInf
, 
mCڡ
.
GTy
().
GAlign
());

283 
	gmCڡ
.
GKd
()) {

284 
	gkCڡAddrof
:

285 
InAddrofCڡ
(
pInf
, 
ic_
<
MIRAddrofCڡ
&>(
mCڡ
), 
d
);

287 
	gkCڡSCڡ
:

288 
InSCڡ
(
pInf
, 
ic_
<
MIRSCڡ
&>(
mCڡ
), 
d
);

290 
	gkCڡI
: {

291 
InICڡ
(
pInf
, 
ic_
<
MIRICڡ
&>(
mCڡ
), 
d
);

294 
	gkCڡAddrofFunc
:

296 
MASSERT
(
l
, "InPorCڡ %d kd NYI", 
mCڡ
.
GKd
());

299 
UpdeGlobVInAddr
(
pInf
, 
mCڡ
.
GTy
().
GSize
());

302 
SBFldCڡ
(
ut8
* 
baFdAddr
, 
ut32
 
baFdSz
, ut32 
bsOfft
, ut8 
bsSize
, 
MIRCڡ
 &
emCڡ
) {

303 
	gMIRICڡ
 &
	gtCڡ
 = 
ic_
<
MIRICڡ
&>(
emCڡ
); ()intConst;

304 
t64
 
	gv
 = 
tCڡ
.
GExtVue
();

305 
ut64
 
	gmask
 = ~(0xfffffffffffffff<< 
bsSize
);

306 
ut64
 
	gom
 = (
v
 & 
mask
<< 
bsOfft
;

307 
	gmask
 = 
mask
 << 
bsOfft
;

308 
	gemCڡ
.
GTy
().
GPrimTy
()) {

309 
	gPTY_i64
:

310 *(
t64
*)
baFdAddr
 = ((*(t64*)baFdAddr& ~(
mask
)| 
om
;

312 
	gPTY_i32
:

313 *(
t32
*)
baFdAddr
 = ((*(t32*)baFdAddr& ~(
mask
)| 
om
;

315 
	gPTY_i16
:

316 *(
t16
*)
baFdAddr
 = ((*(t16*)baFdAddr& ~(
mask
)| 
om
;

318 
	gPTY_i8
:

319 *(
t8
*)
baFdAddr
 = ((*(t8*)baFdAddr& ~(
mask
)| 
om
;

321 
	gPTY_u64
:

322 *(
ut64
*)
baFdAddr
 = ((*(ut64*)baFdAddr& ~(
mask
)| 
om
;

324 
	gPTY_u32
:

325 *(
ut32
*)
baFdAddr
 = ((*(ut32*)baFdAddr& ~(
mask
)| 
om
;

327 
	gPTY_u16
:

328 *(
ut16
*)
baFdAddr
 = ((*(ut16*)baFdAddr& ~(
mask
)| 
om
;

330 
	gPTY_u8
:

331 *(
ut8
*)
baFdAddr
 = ((*(ut8*)baFdAddr& ~(
mask
)| 
om
;

334 
MASSERT
(
l
, "Unexpectedrimaryype");

339 
	gLmbcMod
::
InBFldCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
emCڡ
, 
t32
 &
locdBs
, 
bo
 &
fAlign
) {

340 
ut8
 
	gbFdWidth
 = 
ic_
<
MIRBFldTy
&>(
emCڡ
.
GTy
()).
GFldSize
();

341 i(!
	gbFdWidth
) {

342 
	gfAlign
 = 
ue
;

345 i(
	gfAlign
) {

346 
	gaggrInOfft
 +(
locdBs
 + 7) >> 3;

347 
	gfAlign
 = 
l
;

349 
ut32
 
	gbaFdSz
 = 
GPrimTySize
(
emCڡ
.
GTy
().
GPrimTy
());

350 
ut32
 
	gign
 = 
locdBs
 ? 1 : 
baFdSz
;

351 
ut8
* 
	gbaFdAddr
 = 
GGlobVInAddr
(
pInf
, 
ign
);

353 i(
	glocdBs
 + 
	gbFdWidth
 > (
	gbaFdSz
 * 8)) {

354 
	gbaFdAddr
 = 
baFdAddr
 + 
baFdSz
;

355 
SBFldCڡ
(
baFdAddr
, 
baFdSz
, 0, 
bFdWidth
, 
emCڡ
);

356 
	gaggrInOfft
+
baFdSz
;

357 
	glocdBs
 = 
bFdWidth
;

359 
SBFldCڡ
(
baFdAddr
, 
baFdSz
, 
locdBs
, 
bFdWidth
, 
emCڡ
);

360 
	glocdBs
 +
bFdWidth
;

364 
	gLmbcMod
::
InAggCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
) {

365 aut&
	gTy
 = 
ic_
<
MIRSuTy
&>(
mCڡ
.
GTy
());

366 aut&
	gaggCڡ
 = 
ic_
<
MIRAggCڡ
&>(
mCڡ
);

367 
bo
 
	gfAlign
 = 
l
;

368 
t32
 
	glocdBs
 = 0;

370 
AlignOfft
(
aggrInOfft
, 
aggCڡ
.
GTy
().
GAlign
());

371 
MIRTyKd
 
	gevEmKd
 = 
kTyUnknown
;

372 
ut32
 
	gi
 = 0, 
	gevInFd
 = 0; i < 
	gaggCڡ
.
GCڡVec
().
size
(); ++i) {

373 
	gMIRCڡ
 &
	gemCڡ
 = *
aggCڡ
.
GCڡVecIm
(
i
);

374 
	gMIRTy
 &
	gemTy
 = 
emCڡ
.
GTy
();

378 i(
	gevEmKd
 =
kTyBFld
 && 
emTy
.
GKd
() != kTypeBitField) {

379 
fAlign
 = 
l
;

380 i(
	glocdBs
) {

381 
	gaggrInOfft
 +(
locdBs
 + 7) >> 3;

382 
	glocdBs
 = 0;

387 i(
	gTy
.
GKd
(!
kTyAay
) {

388 
CheckUmedBFld
(
Ty
, 
evInFd
, 
aggCڡ
.
GFldIdIm
(
i
), 
locdBs
);

390 
	gemTy
.
GKd
()) {

391 
	gkTySr
:

392 
InSrCڡ
(
pInf
, 
emCڡ
);

394 
	gkTySu
:

395 
kTyUni
:

396 
InAggCڡ
(
pInf
, 
emCڡ
);

398 
	gkTyAay
:

399 
InAayCڡ
(
pInf
, 
emCڡ
);

401 
	gkTyPor
:

402 
InPorCڡ
(
pInf
, 
emCڡ
);

404 
	gkTyBFld
: {

405 
InBFldCڡ
(
pInf
, 
emCڡ
, 
locdBs
, 
fAlign
);

409 
MASSERT
(
l
, " suy %d NYI", 
emTy
.
GKd
());

413 
	gevEmKd
 = 
emTy
.
GKd
();

417 
	gLmbcMod
::
InSrCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
) {

418 
ut8
 *
	gd
 = 
GGlobVInAddr
(
pInf
, 
mCڡ
.
GTy
().
GAlign
());

419 
	gmCڡ
.
GKd
()) {

420 
	gkCڡI
:

421 
InICڡ
(
pInf
, 
ic_
<
MIRICڡ
&>(
mCڡ
), 
d
);

423 
	gkCڡFltCڡ
:

424 
InFltCڡ
(
pInf
, 
ic_
<
MIRFltCڡ
&>(
mCڡ
), 
d
);

426 
	gkCڡDoubCڡ
:

427 
InDoubCڡ
(
pInf
, 
ic_
<
MIRDoubCڡ
&>(
mCڡ
), 
d
);

429 
	gkCڡSCڡ
:

430 
InSCڡ
(
pInf
, 
ic_
<
MIRSCڡ
&>(
mCڡ
), 
d
);

432 
	gkCڡLblCڡ
:

433 
InLblCڡ
(
pInf
, 
ic_
<
MIRLblCڡ
&>(
mCڡ
), 
d
);

435 
	gkCڡS16Cڡ
:

436 
kCڡAddrof
:

437 
kCڡAddrofFunc
:

439 
MASSERT
(
l
, "SϸCڡ Ty %d NYI", 
mCڡ
.
GKd
());

442 
UpdeGlobVInAddr
(
pInf
, 
mCڡ
.
GTy
().
GSize
());

445 
	gLmbcMod
::
InAayCڡ
(
VInf
 *
pInf
, 
MIRCڡ
 &
mCڡ
) {

446 
	gMIRAayTy
 &
	gyTy
 = 
ic_
<
MIRAayTy
&>(
mCڡ
.
GTy
());

447 
	gMIRAggCڡ
 &
	gyCt
 = 
ic_
<
MIRAggCڡ
&>(
mCڡ
);

448 
AlignOfft
(
aggrInOfft
, 
yTy
.
GAlign
());

450 
size_t
 
	guNum
 = 
yCt
.
GCڡVec
().
size
();

451 
ut32
 
	gdim
 = 
yTy
.
GSizeAayIm
(0);

452 
TyIdx
 
	gsrIdx
 = 
yTy
.
GEmTyIdx
();

453 
MIRTy
 *
	gsubTy
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
srIdx
);

454 i(
	guNum
 =0 && 
dim
 != 0) {

455 
subTy
->
GKd
(=
kTyAay
) {

456 
MIRAayTy
 *
aSubTy
 = 
ic_
<MIRAayTy *>(
subTy
);

457 i(
	gaSubTy
->
GSizeAayIm
(0) > 0) {

458 
	gdim
 *(
aSubTy
->
GSizeAayIm
(0));

460 
	gsrIdx
 = 
aSubTy
->
GEmTyIdx
();

461 
	gsubTy
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
srIdx
);

464 
size_t
 
	gi
 = 0; i < 
	guNum
; ++i) {

465 
MIRCڡ
 *
	gemCڡ
 = 
yCt
.
GCڡVecIm
(
i
);

466 i(
IsPrimiveVe
(
subTy
->
GPrimTy
())) {

467 
MASSERT
(
l
, "Unexpectedrimitive vector");

468 } i(
IsPrimiveSr
(
emCڡ
->
GTy
().
GPrimTy
())) {

469 
bo
 
	grL
 = 
l
;

470 i(
	gyTy
.
GDim
() == 1) {

471 
MIRTy
 *
y
 = 
yTy
.
GEmTy
();

472 i(
	gy
->
GPrimTy
(=
PTY_i8
 || 
y
->GPrimTy(=
PTY_u8
) {

473 
rL
 = 
ue
;

476 
InSrCڡ
(
pInf
, *
emCڡ
);

477 } i(
	gemCڡ
->
GTy
().
GKd
(=
kTyAay
) {

478 
InAayCڡ
(
pInf
, *
emCڡ
);

479 } i(
	gemCڡ
->
GTy
().
GKd
(=
kTySu
 ||

480 
emCڡ
->
GTy
().
GKd
(=
kTyCss
 ||

481 
emCڡ
->
GTy
().
GKd
(=
kTyUni
) {

482 
InAggCڡ
(
pInf
, *
emCڡ
);

486 
ASSERT
(
l
, "shouldotun here");

491 
	gLmbcMod
::
InAddrofCڡ
(
VInf
 *
pInf
, 
MIRAddrofCڡ
 &
addrofCڡ
, 
ut8
* 
d
) {

492 
StIdx
 
	gIdx
 = 
addrofCڡ
.
GSymbIndex
();

493 
t32
 
	gofft
 = 
addrofCڡ
.
GOfft
();

494 
ut8
 *
	gaddr
 = 
pInf
->
sym
->
IsPUStic
(? 
GVAddr
Inf->
puIdx
, 
Idx
) : GetVarAddr(stIdx);

495 *(
	gut8
**)
	gd
 = 
addr
 + 
offt
;

498 
	gLmbcMod
::
InGlobVb
(
VInf
 *
pInf
) {

499 
MIRCڡ
 *
mCڡ
 = 
pInf
->
sym
->
GKڡ
();

500 
ut8
 *
	gd
 = 
GGlobVInAddr
(
pInf
, 
mCڡ
->
GTy
().
GAlign
());

502 
	gmCڡ
->
GKd
()) {

503 
	gkCڡAggCڡ
:

504 
aggrInOfft
 = 0;

505 
InAggCڡ
(
pInf
, *
mCڡ
);

507 
	gkCڡI
:

508 
InICڡ
(
pInf
, *
ic_
<
MIRICڡ
*>(
mCڡ
), 
d
);

510 
	gkCڡFltCڡ
:

511 
InFltCڡ
(
pInf
, *
ic_
<
MIRFltCڡ
*>(
mCڡ
), 
d
);

513 
	gkCڡDoubCڡ
:

514 
InDoubCڡ
(
pInf
, *
ic_
<
MIRDoubCڡ
*>(
mCڡ
), 
d
);

516 
	gkCڡAddrof
:

517 
InAddrofCڡ
(
pInf
, *
ic_
<
MIRAddrofCڡ
*>(
mCڡ
), 
d
);

519 
	gkCڡSCڡ
:

520 
InSCڡ
(
pInf
, *
ic_
<
MIRSCڡ
*>(
mCڡ
), 
d
);

523 
MASSERT
(
l
, "In MIRCڡy %d NYI", 
mCڡ
->
GKd
());

526 
UpdeGlobVInAddr
(
pInf
, 
mCڡ
->
GTy
().
GSize
());

529 
	gLmbcMod
::
InGlobVs
() {

531 
this
->
globs
 = (
ut8
*)
mloc
his->
globsSize
);

532 
	gthis
->
	gglobSticMem
 = (
ut8
*)
mloc
(
this
->
globSticMemSize
);

533 
memt
(
this
->
globs
, 0,his->
globsSize
);

534 
memt
(
this
->
globSticMem
, 0,his->
globSticMemSize
);

537 cڡut
	g
 : 
globAndSticVs
) {

538 
VInf
 *
pInf
 = 

.
cd
;

539 i(
	gpInf
->
	gsym
->
IsCڡ
()) {

540 
InGlobVb
(
pInf
);

545 
le
 
	gLmbcMod
::
AddGlobV
(
MIRSymb
 &
sym
, 
VInf
 *
pInf
) {

546 
	gglobAndSticVs
[
sym
.
GStIdx
().
FuIdx
()] = 
pInf
;

549 
le
 
	gLmbcMod
::
AddPUSticV
(
PUIdx
 
puIdx
, 
MIRSymb
 &
sym
, 
VInf
 *
pInf
) {

550 
	gglobAndSticVs
[(
ut64
)
puIdx
 << 32 | 
sym
.
GStIdx
().
FuIdx
()] = 
pInf
;

554 
ut8
 *
	gLmbcMod
::
GVAddr
(
StIdx
 
Idx
) {

555 aut

 = 
globAndSticVs
.
fd
(
Idx
.
FuIdx
());

556 
MASSERT
(

 !
globAndSticVs
.
d
(), "global varot found");

557  
	gglobs
 + 
	g
->
	gcd
->
	geIdx
;

561 
ut8
 *
	gLmbcMod
::
GVAddr
(
PUIdx
 
puIdx
, 
StIdx
 
Idx
) {

562 aut
	g
 = 
globAndSticVs
.
fd
(()
puIdx
 << 32 | 
Idx
.
FuIdx
());

563 
MASSERT
(

 !
globAndSticVs
.
d
(), "PUStatic varot found");

564  
	gglobs
 + 
	g
->
	gcd
->
	geIdx
;

567 
LmbcFunc
*

568 
	gLmbcMod
::
LkupLmbcFunc
(
PUIdx
 
puIdx
) {

569 aut

 = 
funcM
.
fd
(
puIdx
);

570  
	g
 =
funcM
.
d
()? 
nuαr
: 

->
cd
;

573 
	gFuncAddr
::
FuncAddr
(
bo
 
lmbcFunc
, *
func
, 
d
::
rg
 
me
, 
ut32
 
fmsAggSz
) {

574 
	gfuncName
 = 
me
;

575 
	gisLmbcFunc
 = 
lmbcFunc
;

576 
	gfmsAggSize
 = 
fmsAggSz
;

577 i(
	gisLmbcFunc
) {

578 
	gfuncP
.
	glmbcFunc
 = (
LmbcFunc
*)
func
;

580 
	gfuncP
.
	gtiveFunc
 = 
func
;

585 
ut32
 
GAggFmsSize
(
MIRFuni
 *
func
) {

586 
ut32
 
	gtٮSize
 = 0;

587 
	gMVe
<
	gFmDef
> &
	gfmDefVec
 = 
func
->
GFmDefVec
();

588 
	gi
 = 0; i < 
	gfmDefVec
.
size
(); i++) {

589 
MIRTy
* 
	gty
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
fmDefVec
[
i
].
fmTyIdx
);

590 i(
	gty
->
GPrimTy
(=
PTY_agg
) {

591 
tٮSize
 +
ty
->
GSize
();

594  
	gtٮSize
;

597 
FuncAddr
* 
	gLmbcMod
::
GFuncAddr
(
PUIdx
 
idx
) {

598 
FuncAddr
 *
ddr
;

599 i(
	gPUIdx2FuncAddr
[
idx
]) {

600  
	gPUIdx2FuncAddr
[
idx
];

602 
MIRFuni
 *
	gfunc
 = 
GlobTabs
::
GFuniTab
().
GFuniFromPuidx
(
idx
);

603 
MASSERT
(
func
, "Functionot found in globalable");

604 i(
IsExtFunc
(
idx
, *
this
)) {

605 
	gddr
 = 
w
 
FuncAddr
(
l
, 
FdExtFunc
(
idx
), 
func
->
GName
(), 
GAggFmsSize
(func));

607 
	gddr
 = 
w
 
FuncAddr
(
ue
, 
LkupLmbcFunc
(
idx
), 
func
->
GName
());

609 
	gPUIdx2FuncAddr
[
idx
] = 
ddr
;

610  
	gddr
;

	@lmbc/src/invoke_method.cpp

15 
	~<ffi.h
>

16 
	~<cdio
>

17 
	~<cmh
>

18 
	~<ims
>

19 
	~<gnu/lib-mes.h
>

21 
	~"mvue.h
"

22 
	~"mimty.h
"

23 
	~"mfuni.h
"

24 
	~"mexessi.h
"

26 
	~"codes.h
"

27 
	~"mas.h
"

29 
mea
 
	gm
 {

31 
thad_lol
 
ut32
 
	g__code_t
 = 0;

32 "C" 
ut32
 
__c_code_t
() {

33  ++
__code_t
;

36 cڡ * 
tyr
(
PrimTy
 
t

__ibu
((
unud
));

37 cڡ * 
tyr
(
PrimTy
 
t
) {

38 
	gt
) {

39 
	gPTY_i8
:  " i8";

40 
	gPTY_i16
:  "i16";

41 
	gPTY_i32
:  "i32";

42 
	gPTY_i64
:  "i64";

43 
	gPTY_u8
:  " u8";

44 
	gPTY_u16
:  "u16";

45 
	gPTY_u32
:  "u32";

46 
	gPTY_u64
:  "u64";

47 
	gPTY_a64
:  "a64";

48 
	gPTY_f32
:  "f32";

49 
	gPTY_f64
:  "f64";

50 
	gPTY_void
:  "---";

51 
	gkPtyInvid
:  "INV";

56 
t64
 
MV2I64
(
MVue
 &
v
) {

57 
	gv
.
	gyp
) {

58 
	gPTY_i64
:

59  
v
.
x
.
i64
;

60 
	gPTY_i32
:

61  (
t64
)
v
.
x
.
i32
;

62 
	gPTY_i16
:

63  (
t64
)
v
.
x
.
i16
;

64 
	gPTY_i8
:

65  (
t64
)
v
.
x
.
i8
;

66 
	gPTY_u32
:

67  (
t64
)
v
.
x
.
u32
;

69 
MASSERT
(
l
, "MVuty %d f i64 cvsi NYI", 
v
.
yp
);

73 
	#MMASK1
 0xffu

	)

74 
	#MMASK2
 0xffffu

	)

75 
	#MMASK3
 0xffffffffu

	)

77 
mld
(
ut8
* 
addr
, 
PrimTy
 
yp
, 
MVue
& 
s
, 
size_t
 
aggSize
=0) {

78 
s
.
yp
 =typ;

79 
	gyp
) {

80 
	gPTY_i8
:

81 
s
.
x
.
i64
 = *(
t8
 *)
addr
;

83 
	gPTY_i16
:

84 
s
.
x
.
i64
 = *(
t16
 *)
addr
;

86 
	gPTY_i32
:

87 
s
.
x
.
i64
 = *(
t32
 *)
addr
;

89 
	gPTY_i64
:

90 
s
.
x
.
i64
 = *(
t64
 *)
addr
;

92 
	gPTY_u8
:

93 
s
.
x
.
u64
 = *(
ut8
 *)
addr
;

95 
	gPTY_u16
:

96 
s
.
x
.
u64
 = *(
ut16
 *)
addr
;

98 
	gPTY_u32
:

99 
s
.
x
.
u64
 = *(
ut32
 *)
addr
;

101 
	gPTY_u64
:

102 
s
.
x
.
u64
 = *(
ut64
 *)
addr
;

104 
	gPTY_f32
:

105 
s
.
x
.
f32
 = *(*)
addr
;

107 
	gPTY_f64
:

108 
s
.
x
.
f64
 = *(*)
addr
;

110 
	gPTY_a64
:

111 
s
.
x
.
a64
 = *(
ut8
 **)
addr
;

113 
	gPTY_agg
:

115 
s
.
x
.
a64
 = 
addr
;

116 
	gs
.
	gaggSize
 = 
aggSize
;

119 
MASSERT
(
l
, "mldty%d NYI", 
yp
);

124 
me
(
ut8
* 
addr
, 
PrimTy
 
yp
, 
MVue
& 
v
, 
bo
 
toVArgSck
 = 
l
) {

125 i(!
IsPrimiveIeg
(
yp
|| !IsPrimiveIeg(
v
.ptyp)) {

126 
MASSERT
(
yp
 =
v
.ptyp ||

127 
yp
 =
PTY_a64
 && 
v
.y=
PTY_u64
 ||

128 
yp
 =
PTY_u64
 && 
v
.y=
PTY_a64
,

129 "mܐty mismch: %dnd %d", 
yp
, 
v
.ptyp);

131 
	gyp
) {

132 
	gPTY_i8
:

133 *(
t8
 *)
addr
 = 
v
.
x
.
i8
;

135 
	gPTY_i16
:

136 *(
t16
 *)
addr
 = 
v
.
x
.
i16
;

138 
	gPTY_i32
:

139 *(
t32
 *)
addr
 = 
v
.
x
.
i32
;

141 
	gPTY_i64
:

142 *(
t64
 *)
addr
 = 
v
.
x
.
i64
;

144 
	gPTY_u8
:

145 *(
ut8
 *)
addr
 = 
v
.
x
.
u8
;

147 
	gPTY_u16
:

148 *(
ut16
 *)
addr
 = 
v
.
x
.
u16
;

150 
	gPTY_u32
:

151 *(
ut32
 *)
addr
 = 
v
.
x
.
u32
;

153 
	gPTY_u64
:

154 *(
ut64
 *)
addr
 = 
v
.
x
.
u64
;

156 
	gPTY_f32
:

157 *(*)
addr
 = 
v
.
x
.
f32
;

159 
	gPTY_f64
:

160 *(*)
addr
 = 
v
.
x
.
f64
;

162 
	gPTY_a64
:

163 *(
ut8
 **)
addr
 = 
v
.
x
.
a64
;

165 
	gPTY_agg
:

166 i(
toVArgSck
) {

167 i(
v
.
aggSize
 > 16) {

168 *(
ut8
 **)
addr
 = 
v
.
x
.
a64
;

170 
memy
(
addr
, 
v
.
x
.
a64
, v.
aggSize
);

174 
MASSERT
(
v
.
aggSize
 <= 16, "mstoregg > 16");

175 
memy
(
addr
, &(
v
.
x
.
u64
), v.
aggSize
);

179 
MASSERT
(
l
, "mܐy%d NYI", 
yp
);

184 
bo
 
IsZo
(
MVue
& 
cd
) {

185 
	gcd
.
	gyp
) {

186 
	gPTY_u8
:  
cd
.
x
.
u8
 == 0;

187 
	gPTY_u16
:  
cd
.
x
.
u16
 == 0;

188 
	gPTY_u32
:  
cd
.
x
.
u32
 == 0;

189 
	gPTY_u64
:  
cd
.
x
.
u64
 == 0;

190 
	gPTY_i8
:  
cd
.
x
.
i8
 == 0;

191 
	gPTY_i16
:  
cd
.
x
.
i16
 == 0;

192 
	gPTY_i32
:  
cd
.
x
.
i32
 == 0;

193 
	gPTY_i64
:  
cd
.
x
.
i64
 == 0;

194 : 
MASSERT
(
l
, "IsZty %d NYI", 
cd
.
yp
);

198 
bo


199 
RegAssignZextOrSext
(
MVue
& 
om
, 
PrimTy
 
toTyp
, MVue& 
to
) {

200 
	gtoTyp
) {

201 
	gPTY_u8
:

202 
om
.
yp
) {

203 
PTY_u32
: 
to
.
x
.
u8
 = 
om
.x.
u32
; ;

204 :  
l
;

207 
	gPTY_u32
:

208 
om
.
yp
) {

209 
PTY_u8
: 
to
.
x
.
u64
 = 
om
.x.
u8
; ;

210 
	gPTY_u16
: 
to
.
x
.
u64
 = 
om
.x.
u16
; ;

211 
	gPTY_i32
: 
to
.
x
.
u64
 = 
om
.x.
i32
; ;

212 :  
l
;

215 
	gPTY_i32
:

216 
om
.
yp
) {

217 
PTY_i8
: 
to
.
x
.
i64
 = 
om
.x.
i8
; ;

218 
	gPTY_i16
: 
to
.
x
.
i64
 = 
om
.x.
i16
; ;

219 
	gPTY_u32
: 
to
.
x
.
i64
 = 
om
.x.
u32
; ;

220 :  
l
;

223 
	gPTY_u64
:

224 
om
.
yp
) {

225 
PTY_u8
: 
to
.
x
.
u64
 = 
om
.x.
u8
; ;

226 
	gPTY_u16
: 
to
.
x
.
u64
 = 
om
.x.
u16
; ;

227 
	gPTY_u32
: 
to
.
x
.
u64
 = 
om
.x.
u32
; ;

228 
	gPTY_i64
: 
to
.
x
.
u64
 = 
om
.x.
i64
; ;

229 :  
l
;

232 
	gPTY_i64
:

233 
om
.
yp
) {

234 
PTY_i8
: 
to
.
x
.
i64
 = 
om
.x.
i8
; ;

235 
	gPTY_i16
: 
to
.
x
.
i64
 = 
om
.x.
i16
; ;

236 
	gPTY_i32
: 
to
.
x
.
i64
 = 
om
.x.
i32
; ;

237 :  
l
;

240 
	gPTY_i16
:

241 
om
.
yp
) {

242 
PTY_i32
: 
to
.
x
.
i16
 = 
om
.x.
i32
; ;

243 
	gPTY_u16
: 
to
.
x
.
i16
 = 
om
.x.
u16
; ;

244 :  
l
;

247 
	gPTY_u16
:

248 
om
.
yp
) {

249 
PTY_u32
: 
to
.
x
.
u16
 = 
om
.x.
i32
; ;

250 :  
l
;

254  
l
;

257 
	gto
.
	gyp
 = 
toTyp
;

258  
	gue
;

261 
	#CASE_TOPTYP
(
toPtyp
, 
toCtyp
) \

262 
PTY_
##
toPtyp
: \

263 i(
cvtI

s
.
x
.
toPtyp
 = (
toCtyp
)
omI
; \

264 i(
cvtUt

s
.
x
.
toPtyp
 = (
toCtyp
)
omUt
; \

265 i(
cvtf32

s
.
x
.
toPtyp
 = (
toCtyp
)
omFlt
; \

266 i(
cvtf64

s
.
x
.
toPtyp
 = (
toCtyp
)
omDoub
; \

267 ;

	)

269 
MVue
 
CvtTy
(MVu&
nd
, 
PrimTy
 
toPtyp
, PrimTy 
omPtyp
) {

270 
MVue
 
	gs
;

271 
t64
 
	gomI
;

272 
ut64
 
	gomUt
;

273 
	gomFlt
;

274 
	gomDoub
;

275 
bo
 
	gcvtI
 = 
l
;

276 
bo
 
	gcvtUt
 = 
l
;

277 
bo
 
	gcvtf32
 = 
l
;

278 
bo
 
	gcvtf64
 = 
l
;

280 i(
	gnd
.
	gyp
 =
toPtyp
) {

281  
nd
;

283 
	gomPtyp
) {

284 
	gPTY_i8
: 
omI
 = 
nd
.
x
.
i8
; 
	gcvtI
 = 
ue
; ;

285 
	gPTY_i16
: 
omI
 = 
nd
.
x
.
i16
; 
	gcvtI
 = 
ue
; ;

286 
	gPTY_i32
: 
omI
 = 
nd
.
x
.
i32
; 
	gcvtI
 = 
ue
; ;

287 
	gPTY_i64
: 
omI
 = 
nd
.
x
.
i64
; 
	gcvtI
 = 
ue
; ;

288 
	gPTY_u8
: 
omUt
 = 
nd
.
x
.
u8
; 
	gcvtUt

ue
; ;

289 
	gPTY_u16
: 
omUt
 = 
nd
.
x
.
u16
; 
	gcvtUt

ue
; ;

290 
	gPTY_u32
: 
omUt
 = 
nd
.
x
.
u32
; 
	gcvtUt

ue
; ;

291 
	gPTY_u64
: 
omUt
 = 
nd
.
x
.
u64
; 
	gcvtUt

ue
; ;

292 
	gPTY_a64
: 
omUt
 = 
nd
.
x
.
u64
; 
	gcvtUt

ue
; ;

293 
	gPTY_r
: 
omUt
 = 
nd
.
x
.
u64
; 
	gcvtUt

ue
; ;

294 
	gPTY_f32
: 
omFlt
 = 
nd
.
x
.
f32
; 
	gcvtf32
 = 
ue
; ;

295 
	gPTY_f64
: 
omDoub

nd
.
x
.
f64
; 
	gcvtf64
 = 
ue
; ;

296 : 
MASSERT
(
l
, "OP_cvomty%d NYI", 
omPtyp
); ;

298 
	gtoPtyp
) {

299 
CASE_TOPTYP
(
i8
, 
t8
)

300 
CASE_TOPTYP
(
i16
, 
t16
)

301 
CASE_TOPTYP
(
i32
, 
t32
)

302 
CASE_TOPTYP
(
i64
, 
t64
)

303 
CASE_TOPTYP
(
u8
, 
ut8
)

304 
CASE_TOPTYP
(
u16
, 
ut16
)

305 
CASE_TOPTYP
(
u32
, 
ut32
)

306 
CASE_TOPTYP
(
u64
, 
ut64
)

307 
CASE_TOPTYP
(
f32
, )

308 
CASE_TOPTYP
(
f64
, )

309 
	gPTY_a64
:

310 i(
cvtI
)

311 
s
.
x
.
a64
 = (
ut8
*)
omI
;

312 i(
	gcvtUt
)

313 
	gs
.
	gx
.
	ga64
 = (
ut8
*)
omUt
;

315 
MASSERT
(
l
, "OP_cvt:y %d%d su܋d", 
omPtyp
, 
toPtyp
);

317 : 
MASSERT
(
l
, "OP_cvt:y %d%d NYI", 
omPtyp
, 
toPtyp
);

319 
	gs
.
	gyp
 = 
toPtyp
;

320  
	gs
;

324 
LdArgs
(
MFuni
& 
func
) {

325 
	gi
=0; i < 
	gfunc
.
	gfo
->
	gfmsNum
; ++i) {

326 i(
	gfunc
.
	gfo
->
	gpos2Pm
[
i
]->
	gisPg
) {

327 
	gfunc
.
	gpRegs
[
func
.
fo
->
pos2Pm
[
i
]->
	geIdx
] = func.
Δ
->
Args
[i];

329 
	gfunc
.
	gfmVs
[
func
.
fo
->
pos2Pm
[
i
]->
	geIdx
] = func.
Δ
->
Args
[i];

334 
bo
 
ComFlt
(
x
, 
y
, 
s
 = 0.00000001f) {

335 i(
isf
(
x
&& isf(
y
)) {

336  
ue
;

338  (
bs
(
x
 - 
y
< 
	gs
? 
	gue
 : 
l
;

341 
le
 
bo
 
ComDoub
(
x
, 
y
, 
s
 = 0.0000000000000001f) {

342 i(
isf
(
x
&& isf(
y
)) {

343  
ue
;

345  (
bs
(
x
 - 
y
< 
	gs
? 
	gue
 : 
l
;

348 
HdFltEq
(
Opcode
 

, 
PrimTy
 
ndTy
, 
MVue
 &
s
, MVu&
1
, MVu&
2
) {

349 
MASSERT
(
ndTy
 =
1
.
yp
 && op1.y=
2
.ptyp, "Operandype mismatch %d %d", op1.ptyp, op2.ptyp);

350 
	g
) {

351 
	gOP_
:

352 i(
ndTy
 =
PTY_f32
) {

353 
s
.
x
.
i64
 = !
ComFlt
(
1
.x.
f32
, 
2
.x.f32);

354 } i(
	gndTy
 =
PTY_f64
) {

355 
s
.
x
.
i64
 = !
ComDoub
(
1
.x.
f64
, 
2
.x.f64);

357 
MASSERT
(
l
, "Unexpectedype");

360 
	gOP_eq
:

361 i(
ndTy
 =
PTY_f32
) {

362 
s
.
x
.
i64
 = 
ComFlt
(
1
.x.
f32
, 
2
.x.f32);

363 } i(
	gndTy
 =
PTY_f64
) {

364 
s
.
x
.
i64
 = 
ComDoub
(
1
.x.
f64
, 
2
.x.f64);

366 
MASSERT
(
l
, "Unexpectedype");

374 
ut32
 
GVaArgSize
(
MFuni
 &
Δ
, 
numArgs
, 
LmbcFunc
 *
Info
) {

375 
ut32
 
	gvaArgSize
 = 0;

376 
	gi
 = 
Info
->
fmsNum
; i < 
	gnumArgs
; ++i) {

377 i(
	gΔ
.
	gArgs
[
i
].
	gyp
 !
PTY_agg
 || 
Δ
.
Args
[i].
aggSize
 > 16 ) {

378 
vaArgSize
 += 8;

380 
	gvaArgSize
 +
Δ
.
Args
[
i
].
aggSize
;

383  
	gvaArgSize
;

386 
SupVaArg
(
MFuni
 &
Δ
, 
numArgs
, 
LmbcFunc
 *
Info
) {

387 
	gi
 = 
Info
->
fmsNum
, 
	gofft
 = 0; i < 
	gnumArgs
; ++i) {

388 
me
(
Δ
.
vaArgs
 + 
offt
, cr.
Args
[
i
].
yp
, cr.Args[i], 
ue
);

389 i(
	gΔ
.
	gArgs
[
i
].
	gyp
 !
PTY_agg
 || 
Δ
.
Args
[i].
aggSize
 > 16 ) {

390 
offt
 += 8;

392 
	gofft
 +
Δ
.
Args
[
i
].
aggSize
;

398 
MVue
 
InvokeFunc
(
LmbcFunc
* 

, 
MFuni
 *
Δ
) {

399 
MVue
 
	gtV
;

400 
MVue
 
	gegs
[

->
numPgs
];

401 
MVue
 
	gfmVs
[

->
fmsNumVs
+1];

402 
igs
(8
ut8
 
	game
[

->
ameSize
];

403 
MFuni
 
mfunc
(

, 
Δ
, 
ame
, 
egs
, 
fmVs
);

405 * cڡ 
	gbs
[] = {

406 &&
b_OP_Undef
,

407 
	#OPCODE
(
ba_node
,
dummy1
,
dummy2
,
dummy3
&&
b_OP_
##ba_node,

	)

408 
	~"codes.def
"

409 #unde
OPCODE


410 &&
b_OP_Undef


413 
LdArgs
(
mfunc
);

414 
	gmfunc
.
	gloMem
 = 
ic_
<
ut8
*>(
lo
(
ALLOCA_MEMMAX
));

416 
StmtNode
 *
	gmt
 = 
mfunc
.
xtStmt
;

417 *(
	gbs
[
mt
->

]);

419 
	gb_OP_Undef
:

421 
MASSERT
(
l
, "Hit OP_undef");

423 
	gb_OP_block
:

425 
mt
 = 
ic_
<
BlockNode
*>(mt)->
GF
();

426 
	gmfunc
.
	gxtStmt
 = 
mt
;

427 *(
	gbs
[
mt
->

]);

429 
	gb_OP_ssignoff
:

431 
IassignFPoffNode
* 
node
 = 
ic_
<IassignFPoffNod*>(
mt
);

432 
t32
 
	gofft

node
->
GOfft
();

433 
BaNode
* 
	grhs
 = 
node
->
GRHS
();

434 
MVue
 
	gv
 = 
EvEx
(
mfunc
, 
rhs
);

435 
PrimTy
 
	gyp
 = 
node
->
yp
;

436 
me
(
mfunc
.

+
offt
, 
yp
, 
v
);

438 
	gmt
 = 
mt
->
GNext
();

439 
	gmfunc
.
	gxtStmt
 = 
mt
;

440 *(
	gbs
[
mt
->

]);

441 
	gb_OP_
:

443 
ClNode
 *

 = 
ic_
<ClNode*>(
mt
);

444 
MVue
 
	gArgs
[

->
NumOds
()];

445 
	gmfunc
.
	gArgs
 = 
Args
;

446 
	gmfunc
.
	gnumClArgs
 = 

->
NumOds
();

447 i(
IsExtFunc
(

->
GPUIdx
(), *
mfunc
.
fo
->
lmbcMod
)) {

448 
	gmfunc
.
ClExtFuncDe
(

);

450 
	gmfunc
.
ClMFuncDe
(

);

453 
	gmt
 = 
mt
->
GNext
();

454 
	gmfunc
.
	gxtStmt
 = 
mt
;

455 *(
	gbs
[
mt
->

]);

456 
	gb_OP_gassign
:

458 
RegassignNode
* 
node
 = 
ic_
<RegassignNode*>(
mt
);

459 
PgIdx
 
	ggIdx
 = 
node
->
GRegIdx
();

460 
MVue
 
	grhs
 = 
EvEx
(
mfunc
, 
node
->
GRHS
());

461 i(
	gnode
->
	gyp
 =
rhs
.
yp
) {

462 
MASSERT
(
gIdx
 !-
kSgRv1
, "regassigno %%%%retval1");

463 i(
	ggIdx
 =-
kSgRv0
) {

464 i(
node
->
yp
 !
PTY_agg
) {

465 
Δ
->
tV0
 = 
rhs
;

469 
MASSERT
(
rhs
.
aggSize
 <= 16, "regassign ofgg >16 byteso %%retval0");

470 
ut64
 
	gtv
[2] = {0, 0};

471 
memy
(
tv
, 
rhs
.
x
.
a64
,hs.
aggSize
);

472 
	gΔ
->
	gtV0
.
	gx
.
	gu64
 = 
tv
[0];

473 
	gΔ
->
	gtV0
.
	gyp
 = 
PTY_agg
;

474 
	gΔ
->
	gtV0
.
	gaggSize
 = 
rhs
.
aggSize
;

475 i(
	grhs
.
	gaggSize
 > 8) {

476 
	gΔ
->
	gtV1
.
	gx
.
	gu64
 = 
tv
[1];

477 
	gΔ
->
	gtV1
.
	gyp
 = 
PTY_agg
;

478 
	gΔ
->
	gtV1
.
	gaggSize

rhs
.
aggSize
;

482 
MASSERT
(
gIdx
 < 

->
numPgs
, "regassignegIdx %d out of bound",egIdx);

483 
	gmfunc
.
	gpRegs
[
gIdx
] = 
rhs
;

486 
bo
 
	gexnded
 = 
l
;

487 i(
	ggIdx
 =-
kSgRv0
) {

488 
exnded
 = 
RegAssignZextOrSext
(
rhs
, 
node
->
yp
, 
Δ
->
tV0
);

489 } i(
	ggIdx
 =-
kSgRv1
) {

490 
exnded
 = 
RegAssignZextOrSext
(
rhs
, 
node
->
yp
, 
Δ
->
tV1
);

492 
MASSERT
(
gIdx
 < 

->
numPgs
, "regassignegIdx %d out of bound",egIdx);

493 
	gexnded
 = 
RegAssignZextOrSext
(
rhs
, 
node
->
yp
, 
mfunc
.
pRegs
[
gIdx
]);

495 i(!
	gexnded
) {

496 i((
	gnode
->
	gyp
 =
PTY_a64
 || 
node
->
yp
 =
PTY_u64
) &&

497 (
rhs
.
yp
 =
PTY_a64
 ||hs.y=
PTY_u64
)) {

498 
mfunc
.
pRegs
[
gIdx
] = 
rhs
;

499 
	gmfunc
.
	gpRegs
[
gIdx
].
	gyp
 = 
node
->
yp
;

502 
	gmfunc
.
	gpRegs
[
gIdx
] = 
CvtTy
(
rhs
, 
node
->
yp
,hs.ptyp);

507 
	gmt
 = 
mt
->
GNext
();

508 
	gmfunc
.
	gxtStmt
 = 
mt
;

509 *(
	gbs
[
mt
->

]);

510 
	gb_OP_brl
:

511 
b_OP_brue
:

513 
CdGoNode
* 
node
 = 
ic_
<CdGoNode*>(
mt
);

514 
ut32
 
	gbIdx
 = 
node
->
GOfft
(); ()labelIdx;

515 
MVue
 
	gcd
 = 
EvEx
(
mfunc
, 
node
->
GRHS
());

516 
StmtNode
* 
	gb
 = 

->
bM
[
bIdx
];

517 i(
	gmt
->
	g
 =
OP_brl
 && 
IsZo
(
cd
)
mt
 = 
b
;

518 i(
	gmt
->
	g
 =
OP_brue
 && !
IsZo
(
cd
)
mt
 = 
b
;

520 
	gmt
 = 
mt
->
GNext
();

521 
	gmfunc
.
	gxtStmt
 = 
mt
;

522 *(
	gbs
[
mt
->

]);

523 
	gb_OP_b
:

525 
mt
 = stmt->
GNext
();

526 
	gmfunc
.
	gxtStmt
 = 
mt
;

527 *(
	gbs
[
mt
->

]);

528 
	gb_OP_go
:

530 
ut32
 
bIdx
 = 
ic_
<
GoNode
*>(
mt
)->
GOfft
();

531 
StmtNode
* 
	gb
 = 

->
bM
[
bIdx
];

532 
	gmt
 = 
b
;

534 
	gmt
 = 
mt
->
GNext
();

535 
	gmfunc
.
	gxtStmt
 = 
mt
;

536 *(
	gbs
[
mt
->

]);

537 
	gb_OP_tu
:

538  
Δ
->
tV0
;

539 
	gb_OP_ssignoff
:

541 
IassignoffNode
* 
node
 = 
ic_
<IassignoffNode*>(
mt
);

542 
t32
 
	gofft
 = 
node
->
GOfft
();

543 
MVue
 
	gaddr
 = 
EvEx
(
mfunc
, 
node
->
Od
(0));

544 
MVue
 
	grhs
 = 
EvEx
(
mfunc
, 
node
->
Od
(1));

545 
me
(
addr
.
x
.
a64
 + 
offt
, 
mt
->
yp
, 
rhs
);

547 
	gmt
 = 
mt
->
GNext
();

548 
	gmfunc
.
	gxtStmt
 = 
mt
;

549 *(
	gbs
[
mt
->

]);

550 
	gb_OP_blkassignoff
:

552 
BlkassignoffNode
* 
node
 = 
ic_
<BlkassignoffNode*>(
mt
);

554 
t32
 
	gdOfft
 = 
node
->
offt
;

555 
t32
 
	gblkSize
 = 
node
->
blockSize
;

556 
MVue
 
	gdAddr
 = 
EvEx
(
mfunc
, 
node
->
Od
(0));

557 
MVue
 
	gcAddr
 = 
EvEx
(
mfunc
, 
node
->
Od
(1));

558 
memy
(
dAddr
.
x
.
a64
 + 
dOfft
, 
cAddr
.x.a64, 
blkSize
);

560 
	gmt
 = 
mt
->
GNext
();

561 
	gmfunc
.
	gxtStmt
 = 
mt
;

562 *(
	gbs
[
mt
->

]);

563 
	gb_OP_iδo
:

565 
INode
 *
iδo
 = 
ic_
<INode*>(
mt
);

566 
MASSERT
(
iδo
->
NumOds
() > 0, "icallprotoum operands is %ld", icallproto->NumOpnds());

568 
MVue
 
	gArgs
[
iδo
->
NumOds
()-1];

569 
	gmfunc
.
	gArgs
 = 
Args
;

570 
	gmfunc
.
	gnumClArgs
 = 
iδo
->
NumOds
()-1;

572 
MVue
 
	gAddr
 = 
EvEx
(
mfunc
, 
iδo
->
Od
(0));

573 
FuncAddr
 *
	gddr
 = 
t_
<FuncAddr*>(
Addr
.
x
.
a64
);

574 i(
	gddr
->
	gisLmbcFunc
) {

575 
	gmfunc
.
ClMFuncInde
(
iδo
, 
ddr
->
funcP
.
lmbcFunc
);

577 
	gmfunc
.
ClExtFuncInde
(
iδo
, 
ddr
->
funcP
.
tiveFunc
);

580 
	gmt
 = 
mt
->
GNext
();

581 
	gmfunc
.
	gxtStmt
 = 
mt
;

582 *(
	gbs
[
mt
->

]);

583 
	gb_OP_ngego
:

585 
RgeGoNode
 *
rgo
 = 
ic_
<RgeGoNode*>(
mt
);

586 
t32
 
	ggOfft
 = 
rgo
->
GTagOfft
();

587 
MVue
 
	gnd
 = 
EvEx
(
mfunc
, 
rgo
->
Od
(0));

588 
t64
 
	gg
 = 
MV2I64
(
nd
);

589 
ut32
 
	gbIdx
 = 
rgo
->
GRgeGoTabIm
(
g
 - 
gOfft
).
cd
;

590 
StmtNode
 *
	gb
 = 

->
bM
[
bIdx
];

591 
	gmt
 = 
b
;

593 
	gmt
 = 
mt
->
GNext
();

594 
	gmfunc
.
	gxtStmt
 = 
mt
;

595 *(
	gbs
[
mt
->

]);

596 
	gb_OP_igo
:

598 
MVue
 
nd
 = 
EvEx
(
mfunc
, 
mt
->
Od
(0));

599 
StmtNode
 *
	gb
 = (StmtNode*)
nd
.
x
.
a64
;

600 
	gmt
 = 
b
;

602 
	gmt
 = 
mt
->
GNext
();

603 
	gmfunc
.
	gxtStmt
 = 
mt
;

604 *(
	gbs
[
mt
->

]);

605 
	gb_OP_sic
:

607 
mfunc
.
ClIrsic
(*
ic_
<
IrsicNode
*>(
mt
));

609 
	gmt
 = 
mt
->
GNext
();

610 
	gmfunc
.
	gxtStmt
 = 
mt
;

611 *(
	gbs
[
mt
->

]);

613 
	gb_OP_dassign
:

614 
b_OP_pssign
:

615 
b_OP_maydassign
:

616 
b_OP_ssign
:

617 
b_OP_do
:

618 
b_OP_dowhe
:

619 
b_OP_if
:

620 
b_OP_whe
:

621 
b_OP_swch
:

622 
b_OP_muiway
:

623 
b_OP_fܗchem
:

624 
b_OP_commt
:

625 
b_OP_ev
:

626 
b_OP_
:

627 
b_OP_lsge
:

628 
b_OP_ls
:

629 
b_OP_asge
:

630 
b_OP_as
:

631 
b_OP_as
:

632 
b_OP_tuas
:

633 
b_OP_assigs
:

634 
b_OP_abt
:

635 
b_OP_asnnu
:

636 
b_OP_assigsnnu
:

637 
b_OP_asnnu
:

638 
b_OP_tuasnnu
:

639 
b_OP_dad
:

640 
b_OP_d
:

641 
b_OP_addrof
:

642 
b_OP_ddrof
:

643 
b_OP_sizeoy
:

644 
b_OP_fldsdi
:

645 
b_OP_y
:

646 
b_OP_vtu
:

647 
b_OP_surass
:

648 
b_OP_r
:

649 
b_OP_cuom
:

650 
b_OP_pymphic
:

651 
b_OP_i
:

652 
b_OP_ri
:

653 
b_OP_vtui
:

654 
b_OP_sicwhty
:

655 
b_OP_xsic
:

656 
b_OP_assigd
:

657 
b_OP_vtuassigd
:

658 
b_OP_surassassigd
:

659 
b_OP_rassigd
:

660 
b_OP_cuomassigd
:

661 
b_OP_pymphicassigd
:

662 
b_OP_iassigd
:

663 
b_OP_riassigd
:

664 
b_OP_vtuiassigd
:

665 
b_OP_sicassigd
:

666 
b_OP_sicwhtyassigd
:

667 
b_OP_xsicassigd
:

668 
b_OP_Κt
:

669 
b_OP_Κssigd
:

670 
b_OP_vtuΚt
:

671 
b_OP_vtuΚssigd
:

672 
b_OP_surassΚt
:

673 
b_OP_surassΚssigd
:

674 
b_OP_rΚt
:

675 
b_OP_rΚssigd
:

676 
b_OP_jry
:

677 
b_OP_y
:

678 
b_OP_ry
:

679 
b_OP_throw
:

680 
b_OP_jstch
:

681 
b_OP_tch
:

682 
b_OP_ptch
:

683 
b_OP_fly
:

684 
b_OP_nury
:

685 
b_OP_dy
:

686 
b_OP_
:

687 
b_OP_d
:

688 
b_OP_un
:

689 
b_OP_dun
:

690 
b_OP_gosub
:

691 
b_OP_tsub
:

692 
b_OP_syn
:

693 
b_OP_synx
:

694 
b_OP_deef
:

695 
b_OP_ef
:

696 
b_OP_deeet
:

697 
b_OP_membacque
:

698 
b_OP_memba
:

699 
b_OP_membܖd
:

700 
b_OP_membee
:

701 
b_OP_doff
:

702 
b_OP_doff
:

703 
b_OP_gad
:

704 
b_OP_addroffunc
:

705 
b_OP_addroab
:

706 
b_OP_cڡv
:

707 
b_OP_cڡr
:

708 
b_OP_cڡr16
:

709 
b_OP_
:

710 
b_OP_cvt
:

711 
b_OP_o
:

712 
b_OP_ty
:

713 
b_OP_round
:

714 
b_OP_unc
:

715 
b_OP_abs
:

716 
b_OP_bn
:

717 
b_OP_
:

718 
b_OP_g
:

719 
b_OP_c
:

720 
b_OP_sq
:

721 
b_OP_xt
:

722 
b_OP_zext
:

723 
b_OP_lo
:

724 
b_OP_mloc
:

725 
b_OP_gcmloc
:

726 
b_OP_gmloc
:

727 
b_OP_ackmloc
:

728 
b_OP_gcmlocjy
:

729 
b_OP_gmlocjy
:

730 
b_OP_ackmlocjy
:

731 
b_OP_sverfunc
:

732 
b_OP_svevtufunc
:

733 
b_OP_add
:

734 
b_OP_sub
:

735 
b_OP_mul
:

736 
b_OP_div
:

737 
b_OP_m
:

738 
b_OP_ashr
:

739 
b_OP_lshr
:

740 
b_OP_shl
:

741 
b_OP_r
:

742 
b_OP_max
:

743 
b_OP_m
:

744 
b_OP_bd
:

745 
b_OP_bi
:

746 
b_OP_bx
:

747 
b_OP_CG_y_em_add
:

748 
b_OP_eq
:

749 
b_OP_ge
:

750 
b_OP_gt
:

751 
b_OP_
:

752 
b_OP_
:

753 
b_OP_
:

754 
b_OP_cmp
:

755 
b_OP_cm
:

756 
b_OP_cmpg
:

757 
b_OP_nd
:

758 
b_OP_li
:

759 
b_OP_nd
:

760 
b_OP_ci
:

761 
b_OP_
:

762 
b_OP_sic
:

763 
b_OP_sicwhty
:

764 
b_OP_exabs
:

765 
b_OP_dosbs
:

766 
b_OP_ssigcoff
:

767 
b_OP_dpcoff
:

768 
b_OP_checkpot
:

769 
b_OP_addrofc
:

770 
b_OP_asm
:

771 
b_OP_dadoff
:

772 
b_OP_addrofoff
:

773 
b_OP_dassignoff
:

774 
b_OP_ssignoff
:

775 
b_OP_iδssigd
:

777 
MASSERT
(
l
, "NIY");

780  
	gtV
;

783 
MVue
 
EvEx
(
MFuni
& 
func
, 
BaNode
* 
ex
, 
PmInf
 *
rm
) {

784 
MVue
 
	gs
;

786 * cڡ 
	gbs
[] = {

787 &&
b_OP_Undef
,

788 
	#OPCODE
(
ba_node
,
dummy1
,
dummy2
,
dummy3
&&
b_OP_
##ba_node,

	)

789 
	~"codes.def
"

790 #unde
OPCODE


791 &&
b_OP_Undef


794 *(
	gbs
[
ex
->

]);

795 
	gb_OP_Undef
:

797 
MASSERT
(
l
, "Hit OP_undef");

799 
	gb_OP_cڡv
:

801 
MIRCڡ
* 
cڡv
 = 
ic_
<
CڡvNode
*>(
ex
)->
GCڡV
();

802 
t64
 
	gcڡI
 = 0;

803 
	gcڡFlt
 = 0;

804 
	gcڡDoub
 = 0;

805 
	gcڡv
->
GKd
()) {

806 
	gkCڡI
:

807 
cڡI
 = 
ic_
<
MIRICڡ
 *>(
cڡv
)->
GExtVue
();

809 
	gkCڡDoubCڡ
:

810 
cڡDoub
 = 
ic_
<
MIRDoubCڡ
 *>(
cڡv
)->
GVue
();

812 
	gkCڡFltCڡ
:

813 
cڡFlt
 = 
ic_
<
MIRFltCڡ
 *>(
cڡv
)->
GVue
();

816 
MASSERT
(
l
, "cڡv kd %d NYI", 
cڡv
->
GKd
());

819 
PrimTy
 
	gyp
 = 
ex
->
yp
;

820 
	gyp
) {

821 
	gPTY_i8
:

822 
PTY_i16
:

823 
PTY_i32
:

824 
PTY_i64
:

825 
MASSERT
(
cڡv
->
GKd
(=
kCڡI
, "ptypnd constval kind mismatch");

826 
	gs
.
	gx
.
	gi64
 = 
cڡI
;

827 
	gs
.
	gyp
 = 
yp
;

829 
	gPTY_u8
:

830 
PTY_u16
:

831 
PTY_u32
:

832 
PTY_u64
:

833 
PTY_a64
:

834 
MASSERT
(
cڡv
->
GKd
(=
kCڡI
, "ptypnd constval kind mismatch");

835 
	gs
.
	gx
.
	gu64
 = 
cڡI
;

836 
	gs
.
	gyp
 = 
yp
;

838 
	gPTY_f32
:

839 
MASSERT
(
cڡv
->
GKd
(=
kCڡFltCڡ
, "ptypnd constval kind mismatch");

840 
	gs
.
	gx
.
	gf32
 = 
cڡFlt
;

841 
	gs
.
	gyp
 = 
yp
;

843 
	gPTY_f64
:

844 
MASSERT
(
cڡv
->
GKd
(=
kCڡDoubCڡ
, "constvaltypnd kind mismatch");

845 
	gs
.
	gx
.
	gf64
 = 
cڡDoub
;

846 
	gs
.
	gyp
 = 
yp
;

849 
MASSERT
(
l
, "y %d f cڡv NYI", 
yp
);

853 
	g_ex
;

855 
	gb_OP_add
:

857 
MVue
 
0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

858 
MVue
 
	g1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

859 
	gex
->
	gyp
) {

860 
	gPTY_i8
: 
s
.
x
.
i8
 = 
0
.x.i8 + 
1
.x.i8; ;

861 
	gPTY_i16
: 
s
.
x
.
i16
 = 
0
.x.i16 + 
1
.x.i16; ;

862 
	gPTY_i32
: 
s
.
x
.
i32
 = (
t64
)
0
.x.i32 + (t64)
1
.x.i32; ;

863 
	gPTY_i64
: 
s
.
x
.
i64
 = (
ut64
)
0
.x.i64 + (ut64)
1
.x.i64; ;

864 
	gPTY_u8
: 
s
.
x
.
u8
 = 
0
.x.u8 + 
1
.x.u8; ;

865 
	gPTY_u16
: 
s
.
x
.
u16
 = 
0
.x.u16 + 
1
.x.u16; ;

866 
	gPTY_u32
: 
s
.
x
.
u32
 = 
0
.x.u32 + 
1
.x.u32; ;

867 
	gPTY_u64
: 
s
.
x
.
u64
 = 
0
.x.u64 + 
1
.x.u64; ;

868 
	gPTY_a64
: 
s
.
x
.
u64
 = 
0
.x.u64 + 
1
.x.u64; ;

869 
	gPTY_f32
: 
s
.
x
.
f32
 = 
0
.x.f32 + 
1
.x.f32; ;

870 
	gPTY_f64
: 
s
.
x
.
f64
 = 
0
.x.f64 + 
1
.x.f64; ;

871 : 
MIR_FATAL
("Unsu܋d PrimTy %d f by ot %s", 
ex
->
yp
, "+");

873 
	gs
.
	gyp
 = 
ex
->
yp
;

875 
	g_ex
;

877 
	gb_OP_sub
:

879 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

880 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

881 
EXPRBINOP
(-, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

882 
	g_ex
;

884 
	gb_OP_mul
:

886 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

887 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

888 
EXPRBINOP
(*, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

889 
	g_ex
;

891 
	gb_OP_div
:

893 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

894 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

895 
EXPRBINOP
(/, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

896 
	g_ex
;

898 
	gb_OP_gad
:

900 
PgIdx
 
gIdx
 = 
ic_
<
RegadNode
*>(
ex
)->
GRegIdx
();

901 
	ggIdx
) {

902 -(
	gkSgFp
):

903 
MASSERT
(
ex
->
yp
 =
PTY_a64
, "regread %%FP with wrongtyp %d",xpr->ptyp);

904 
	gs
.
	gx
.
	ga64
 = 
func
.

;

906 -(
	gkSgRv0
):

907 i(
ex
->
yp
 =
func
.
tV0
.ptyp) {

908 
s
 = 
func
.
tV0
;

909 } i(
	gex
->
	gyp
 =
PTY_agg
 || 
ex
->
yp
 =
PTY_u64
) {

910 
s
 = 
func
.
tV0
;

912 
	gs
 = 
CvtTy
(
func
.
tV0
, 
ex
->
yp
, func.retVal0.ptyp);

915 -(
	gkSgRv1
):

916 
MASSERT
(
ex
->
yp
 =
func
.
tV1
.ptyp ||

917 (
ex
->
yp
 =
PTY_agg
 ||x->y=
PTY_u64
),

918 "gad %%tV0y mismch: %d %d", 
ex
->
yp
, 
func
.
tV1
.ptyp);

919 
	gs
 = 
func
.
tV1
;

921 -(
	gkSgGp
):

922 
MASSERT
(
ex
->
yp
 =
PTY_a64
, "regread %%GP with wrongtyp %d",xpr->ptyp);

923 
	gs
.
	gx
.
	ga64
 = 
func
.
fo
->
lmbcMod
->
globSticMem
;

926 
MASSERT
(
gIdx
 < 
func
.
fo
->
numPgs
, "regreadegIdx %d out of bound",egIdx);

928 
	gs
 = 
func
.
pRegs
[
gIdx
];

931 
	gs
.
	gyp
 = 
ex
->
yp
;

932 
	g_ex
;

934 
	gb_OP_cڡr
:

936 
USIdx
 
urIdx
 = 
ic_
<
CڡrNode
*>(
ex
)->
GSIdx
();

937 aut
	g
 = 
func
.
fo
->
lmbcMod
->
globSTbl
.

(

938 
d
::

<
ut32
, std::
rg
>(
urIdx
, 
GlobTabs
::
GUSTab
().
GSgFromSIdx
(ustrIdx)));

939 
	gs
.
	gx
.
	gr
 = 
cڡ_
<*>(

.
f
->
cd
.
c_r
());

940 
	gs
.
	gyp
 = 
PTY_a64
;

941 
	g_ex
;

943 
	gb_OP_doff
:

945 
IadFPoffNode
* 
node
 = 
ic_
<IadFPoffNod*>(
ex
);

946 
t32
 
	gofft
 = 
node
->
GOfft
();

947 i(
	gnode
->
	gyp
 !
PTY_agg
) {

948 
mld
(
func
.

+
offt
, 
ex
->
yp
, 
s
);

949 
	g_ex
;

958 i(
	gfunc
.
	gxtStmt
->
	g
 =
OP_
) {

960 
MASSERT
(
func
.
aggrArgsBuf
 !
nuαr
, "aggrArgsBuf isull");

961 
memy
(
func
.
aggrArgsBuf
+
rm
->
eIdx
, func.

+
offt
,m->
size
);

962 
mld
(
func
.
aggrArgsBuf
+
rm
->
eIdx
, 
ex
->
yp
, 
s
,m->
size
);

964 
mld
(
func
.

+
offt
, 
ex
->
yp
, 
s
, func.
fo
->
tSize
);

966 
	g_ex
;

968 
	gb_OP_doff
:

970 
t32
 
offt
 = 
ic_
<
IadoffNode
 *>(
ex
)->
GOfft
();

971 
MVue
 
	grhs
 = 
EvEx
(
func
, 
ic_
<
IadoffNode
 *>(
ex
)->
Od
(0));

972 i(
	gex
->
	gyp
 =
PTY_agg
) {

976 
MASSERT
(
rhs
.
yp
 =
PTY_a64
, "ireadoffgg RHSot PTY_agg");

977 i(
	gfunc
.
	gxtStmt
->
	g
 =
OP_
) {

978 
MASSERT
(
func
.
aggrArgsBuf
 !
nuαr
, "aggrArgsBuf isull");

979 
memy
(
func
.
aggrArgsBuf
+
rm
->
eIdx
, 
rhs
.
x
.
a64
 + 
offt
,m->
size
);

980 
mld
(
func
.
aggrArgsBuf
+
rm
->
eIdx
, 
ex
->
yp
, 
s
,m->
size
);

982 
MASSERT
(
func
.
xtStmt
->

 =
OP_gassign
, "ireadoffggot usedsegassigngg opnd");

983 
mld
(
rhs
.
x
.
a64
 + 
offt
, 
ex
->
yp
, 
s
, 
func
.
fo
->
tSize
);

985 
	g_ex
;

987 
MASSERT
(
rhs
.
yp
 =
PTY_a64
 ||hs.y=
PTY_u64
 ||hs.y=
PTY_i64
,

988 "dofrhy%d PTY_a64 oPTY_u64", 
rhs
.
yp
);

989 
mld
(
rhs
.
x
.
a64
+
offt
, 
ex
->
yp
, 
s
);

990 
	g_ex
;

992 
	gb_OP_d
:

994 
MASSERT
(
func
.
xtStmt
->

 =
OP_
 && 
ex
->
yp
 =
PTY_agg
, "iread unexpected outside call");

995 
MVue
 
	gaddr
 = 
EvEx
(
func
, 
ex
->
Od
(0));

996 
MASSERT
(
func
.
aggrArgsBuf
 !
nuαr
, "aggrArgsBuf isull");

997 
memy
(
func
.
aggrArgsBuf
+
rm
->
eIdx
, 
addr
.
x
.
a64
,m->
size
);

998 
mld
(
func
.
aggrArgsBuf
+
rm
->
eIdx
, 
ex
->
yp
, 
s
,m->
size
);

999 
	g_ex
;

1001 
	gb_OP_eq
:

1003 
PrimTy
 
ndTy
 = 
ic_
<
ComNode
*>(
ex
)->
GOdTy
();

1004 
MVue
 
	gnd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1005 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1006 i(
	gndTy
 =
PTY_f32
 || 
ndTy
 =
PTY_f64
) {

1007 
s
.
yp
 = 
ex
->ptyp;

1008 
HdFltEq
(
ex
->

, 
ndTy
, 
s
, 
nd0
, 
nd1
);

1010 
EXPRCOMPOPNOFLOAT
(==, 
s
, 
nd0
, 
nd1
, 
ndTy
, 
ex
->
yp
);

1012 
	g_ex
;

1014 
	gb_OP_
:

1016 
PrimTy
 
ndTy
 = 
ic_
<
ComNode
*>(
ex
)->
GOdTy
();

1017 
MVue
 
	gnd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1018 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1019 i(
	gndTy
 =
PTY_f32
 || 
ndTy
 =
PTY_f64
) {

1020 
s
.
yp
 = 
ex
->ptyp;

1021 
HdFltEq
(
ex
->

, 
ndTy
, 
s
, 
nd0
, 
nd1
);

1023 
EXPRCOMPOPNOFLOAT
(!=, 
s
, 
nd0
, 
nd1
, 
ndTy
, 
ex
->
yp
);

1025 
	g_ex
;

1027 
	gb_OP_gt
:

1029 
PrimTy
 
ndTyp

ic_
<
ComNode
*>(
ex
)->
GOdTy
();

1030 
MVue
 
	gnd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1031 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1032 
EXPRCOMPOP
(>, 
s
, 
nd0
, 
nd1
, 
ndTyp
, 
ex
->
yp
);

1033 
	g_ex
;

1035 
	gb_OP_ge
:

1037 
PrimTy
 
ndTyp

ic_
<
ComNode
*>(
ex
)->
GOdTy
();

1038 
MVue
 
	gnd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1039 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1040 
EXPRCOMPOP
(>=, 
s
, 
nd0
, 
nd1
, 
ndTyp
, 
ex
->
yp
);

1041 
	g_ex
;

1043 
	gb_OP_
:

1045 
PrimTy
 
ndTyp

ic_
<
ComNode
*>(
ex
)->
GOdTy
();

1046 
MVue
 
	gnd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1047 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1048 
EXPRCOMPOP
(<, 
s
, 
nd0
, 
nd1
, 
ndTyp
, 
ex
->
yp
);

1049 
	g_ex
;

1051 
	gb_OP_
:

1053 
PrimTy
 
ndTyp

ic_
<
ComNode
*>(
ex
)->
GOdTy
();

1054 
MVue
 
	gnd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1055 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1056 
EXPRCOMPOP
(<=, 
s
, 
nd0
, 
nd1
, 
ndTyp
, 
ex
->
yp
);

1057 
	g_ex
;

1059 
	gb_OP_
:

1061 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1062 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1063 
MVue
 
	gnd2
 = 
EvEx
(
func
, 
ex
->
Od
(2));

1064 
EXPRSELECTOP
(
s
, 
nd0
, 
nd1
, 
nd2
, 
ex
->
yp
);

1065 
	g_ex
;

1067 
	gb_OP_bd
:

1069 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1070 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1071 
EXPRBININTOP
(&, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

1072 
	g_ex
;

1074 
	gb_OP_bi
:

1076 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1077 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1078 
EXPRBININTOP
(|, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

1079 
	g_ex
;

1081 
	gb_OP_bx
:

1083 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1084 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1085 
EXPRBININTOP
(^, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

1086 
	g_ex
;

1088 
	gb_OP_lshr
:

1090 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1091 
MVue
 
	gnumBs
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1092 
EXPRBININTOPUNSIGNED
(>>, 
s
, 
nd0
, 
numBs
, 
ex
->
yp
);

1093 
	g_ex
;

1095 
	gb_OP_ashr
:

1097 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1098 
MVue
 
	gnumBs
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1099 
EXPRBININTOP
(>>, 
s
, 
nd0
, 
numBs
, 
ex
->
yp
);

1100 
	g_ex
;

1102 
	gb_OP_shl
:

1104 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1105 
MVue
 
	gnumBs
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1106 
EXPRBININTOP
(<<, 
s
, 
nd0
, 
numBs
, 
ex
->
yp
);

1107 
	g_ex
;

1109 
	gb_OP_bn
:

1111 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1112 
EXPRUNROP
(~, 
s
, 
nd0
, 
ex
->
yp
);

1113 
	g_ex
;

1115 
	gb_OP_
:

1117 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1118 
EXPRUNROP
(!, 
s
, 
nd0
, 
ex
->
yp
);

1119 
	g_ex
;

1121 
	gb_OP_g
:

1123 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1124 
	gex
->
	gyp
) {

1125 
	gPTY_i8
: 
s
.
x
.
i8
 = -
nd0
.x.i8; ;

1126 
	gPTY_i16
: 
s
.
x
.
i16
 = -
nd0
.x.i16; ;

1128 
	gPTY_i32
: 
s
.
x
.
i32
 = ~(
ut32
)
nd0
.x.i32+1; ;

1129 
	gPTY_i64
: 
s
.
x
.
i64
 = -
nd0
.x.i64; ;

1130 
	gPTY_u8
: 
s
.
x
.
u8
 = -
nd0
.x.u8; ;

1131 
	gPTY_u16
: 
s
.
x
.
u16
 = -
nd0
.x.u16; ;

1132 
	gPTY_u32
: 
s
.
x
.
u32
 = -
nd0
.x.u32; ;

1133 
	gPTY_u64
: 
s
.
x
.
u64
 = -
nd0
.x.u64; ;

1134 
	gPTY_f32
: 
s
.
x
.
f32
 = -
nd0
.x.f32; ;

1135 
	gPTY_f64
: 
s
.
x
.
f64
 = -
nd0
.x.f64; ;

1136 : 
MIR_FATAL
("Unsu܋d PrimTy %d f ury ot %s", 
ex
->
yp
, "OP_neg");

1138 
	gs
.
	gyp
 = 
ex
->
yp
;

1140 
EXPRUNROP
(-, 
s
, 
nd0
, 
ex
->
yp
);

1142 
	g_ex
;

1144 
	gb_OP_abs
:

1146 
MVue
 
0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1147 
	gex
->
	gyp
) {

1149 
	gPTY_i8
: 
s
.
x
.
i8
 = 
abs
(
0
.x.i8); ;

1150 
	gPTY_i16
: 
s
.
x
.
i16
 = 
abs
(
0
.x.i16); ;

1151 
	gPTY_i32
: 
s
.
x
.
i32
 = 
abs
(
0
.x.i32); ;

1152 
	gPTY_i64
: 
s
.
x
.
i64
 = 
abs
(
0
.x.i64); ;

1153 
	gPTY_f32
: 
s
.
x
.
f32
 = 
bsf
(
0
.x.f32); ;

1154 
	gPTY_f64
: 
s
.
x
.
f64
 = 
bs
(
0
.x.f64); ;

1155 : 
MASSERT
(
l
, "_abunsu܋dy %d", 
ex
->
yp
);

1157 
	gs
.
	gyp
 = 
ex
->
yp
;

1158 
	g_ex
;

1160 
	gb_OP_m
:

1162 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1163 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1164 
EXPRMAXMINOP
(<, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

1165 
	g_ex
;

1167 
	gb_OP_max
:

1169 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1170 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1171 
EXPRMAXMINOP
(>, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

1172 
	g_ex
;

1174 
	gb_OP_m
:

1176 
MVue
 
nd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1177 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1178 
EXPRREMOP
(%, 
s
, 
nd0
, 
nd1
, 
ex
->
yp
);

1179 
	g_ex
;

1181 
	gb_OP_cvt
:

1183 
PrimTy
 
toPtyp
 = 
ex
->
yp
;

1184 
PrimTy
 
	gomPtyp
 = 
ic_
<
TyCvtNode
*>(
ex
)->
FromTy
();

1185 
MVue
 
	gnd
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1186 
	gs
 = 
CvtTy
(
nd
, 
toPtyp
, 
omPtyp
);

1187 
	g_ex
;

1189 
	gb_OP_addrofoff
:

1192 
t32
 
offt
 = 
ic_
<
AddrofoffNode
*>(
ex
)->offset;

1193 
StIdx
 
	gidx
 = 
ic_
<
AddrofoffNode
*>(
ex
)->
Idx
;

1194 
ut8
 *
	gaddr
;

1196 i(
	gidx
.
Iol
()) {

1197 
	gaddr
 = 
func
.
GFmVAddr
(
idx
);

1198 i(!
	gaddr
) {

1199 
	gaddr
 = 
func
.
fo
->
lmbcMod
->
GVAddr
(func.fo->
mFunc
->
GPuidx
(), 
idx
);

1201 
MASSERT
(
addr
, "addrofoff canot findocal var");

1203 
MASSERT
(
idx
.
IsGlob
(), "addrofoff: symboleitherocalor global");

1204 
MIRSymb
* 
	gv
 = 
GlobTabs
::
GGsymTab
().
GSymbFromStidx
(
idx
.
Idx
());

1205 
	gv
->
GStageCss
()) {

1206 
	gkScEx
:

1207 
addr
 = (
ut8
 *)(
func
.
fo
->
lmbcMod
->
FdExtSym
(
idx
));

1209 
	gkScGlob
:

1210 
kScFic
:

1211 
addr
 = 
func
.
fo
->
lmbcMod
->
GVAddr
(
v
->
GStIdx
());

1214 
MASSERT
(
l
, "addrofoff: stagas%d NYI", 
v
->
GStageCss
());

1218 
	gs
.
	gx
.
	ga64
 = 
addr
 + 
offt
;

1219 
	gs
.
	gyp
 = 
PTY_a64
;

1220 
	g_ex
;

1222 
	gb_OP_lo
:

1224 
MVue
 
nd
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1225 
	gs
.
	gyp
 = 
PTY_a64
;

1226 
	gs
.
	gx
.
	ga64
 = 
func
.
Ao
(
nd
.
x
.
u64
);

1227 
	g_ex
;

1229 
	gb_OP_addroffunc
:

1231 
FuncAddr
 *
ddr
 = 
func
.
fo
->
lmbcMod
->
GFuncAddr
(
ic_
<
AddroffuncNode
*>(
ex
)->
GPUIdx
());

1232 
	gs
.
	gx
.
	ga64
 = (
ut8
*)
ddr
;

1233 
	gs
.
	gyp
 = 
PTY_a64
;

1234 
	g_ex
;

1236 
	gb_OP_addroab
:

1238 
AddroabNode
 *
node
 = 
ic_
<AddroabNode*>(
ex
);

1239 
LabIdx
 
	gbIdx
 = 
node
->
GOfft
();

1240 
StmtNode
 *
	gb
 = 
func
.
fo
->
bM
[
bIdx
];

1241 
	gs
.
	gx
.
	ga64
 = 
t_
<
ut8
*>(
b
);

1242 
	gs
.
	gyp
 = 
ex
->
yp
;

1243 
	g_ex
;

1245 
	gb_OP_ty
:

1247 
s
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1248 
	gs
.
	gyp
 = 
ex
->
yp
;

1249 
	g_ex
;

1251 
	gb_OP_xt
:

1253 
ExabsNode
 *
ext
 = 
ic_
<ExabsNode*>(
ex
);

1254 
ut8
 
	gbOfft
 = 
ext
->
GBsOfft
();

1255 
ut8
 
	gbSize
 = 
ext
->
GBsSize
();

1256 
MASSERT
(
bOfft
 == 0, "sext unexpected offset");

1257 
ut64
 
	gmask
 = 
bSize
 < 64 ? (1ull << bSize) - 1 : ~0ull;

1258 
	gs
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1259 
	gs
.
	gx
.
	gi64
 = ((
ut64
)
s
.
x
.
i64
 >> (
bSize
 - 1& 1u?es.x.i64 | ~
mask
 :es.x.i64 & mask;

1260 
	gs
.
	gyp
 = 
ex
->
yp
;

1261 
	g_ex
;

1263 
	gb_OP_zext
:

1265 
ExabsNode
 *
ext
 = 
ic_
<ExabsNode*>(
ex
);

1266 
ut8
 
	gbOfft
 = 
ext
->
GBsOfft
();

1267 
ut8
 
	gbSize
 = 
ext
->
GBsSize
();

1268 
MASSERT
(
bOfft
 == 0, "zext unexpected offset");

1269 
ut64
 
	gmask
 = 
bSize
 < 64 ? (1ull << bSize) - 1 : ~0ull;

1270 
	gs
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1271 
	gs
.
	gx
.
	gi64
 &
mask
;

1272 
	gs
.
	gyp
 = 
ex
->
yp
;

1273 
	g_ex
;

1275 
	gb_OP_exabs
:

1277 
ExabsNode
 *
ebs
 = 
ic_
<ExabsNode*>(
ex
);

1278 
ut8
 
	gbOfft
 = 
ebs
->
GBsOfft
();

1279 
ut8
 
	gbSize
 = 
ebs
->
GBsSize
();

1280 
ut64
 
	gmask
 = ((1u << 
bSize
- 1<< 
bOfft
;

1281 
	gs
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1282 
	gs
.
	gx
.
	gi64
 = (
ut64
)(
s
.
x
.
i64
 & 
mask
>> 
bOfft
;

1283 i(
IsSigdIeg
(
ex
->
yp
)) {

1284 
	gmask
 = (1u << 
bSize
) - 1;

1285 
	gs
.
	gx
.
	gi64
 = ((
ut64
)
s
.
x
.
i64
 >> (
bSize
 - 1& 1u?es.x.i64 | ~
mask
 :es.x.i64 & mask;

1287 
	gs
.
	gyp
 = 
ex
->
yp
;

1288 
	g_ex
;

1290 
	gb_OP_dosbs
:

1292 
DosbsNode
 *
dbs
 = 
ic_
<DosbsNode*>(
ex
);

1293 
MVue
 
	gnd0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1294 
MVue
 
	gnd1
 = 
EvEx
(
func
, 
ex
->
Od
(1));

1295 
ut64
 
	gmask
 = ~(0xfffffffffffffff<< 
dbs
->
GBsSize
());

1296 
ut64
 
	gom
 = (
nd1
.
x
.
u64
 & 
mask
<< 
dbs
->
GBsOfft
();

1297 
	gmask
 = 
mask
 << 
dbs
->
GBsOfft
();

1298 
	gs
.
	gx
.
	gu64
 = (
nd0
.
x
.
u64
 & ~(
mask
)| 
om
;

1299 
	gs
.
	gyp
 = 
ex
->
yp
;

1300 
	g_ex
;

1302 
	gb_OP_sic
:

1304 aut*
n
 = 
ic_
<
IrsicNode
*>(
ex
);

1305 
MVue
 
	g0
 = 
EvEx
(
func
, 
ex
->
Od
(0));

1306 
	gs
.
	gyp
 = 
ex
->
yp
;

1308 
	gn
->
GIrsic
()) {

1309 
	gINTRN_C_s
:

1310 i(
ex
->
yp
 =
PTY_f32
) {

1311 
s
.
x
.
f32
 = 
s
(
0
.x.f32);

1312 } i(
	gex
->
	gyp
 =
PTY_f64
) {

1313 
s
.
x
.
f64
 = 
s
(
0
.x.f64);

1316 
	gINTRN_C_z32
:

1317 i(
ex
->
yp
 =
PTY_u32
 ||x->y=
PTY_i32
) {

1318 
s
.
x
.
u32
 = 
__but_z
(
0
.x.u32);

1321 
	gINTRN_C_z32
:

1322 i(
ex
->
yp
 =
PTY_u32
 ||x->y=
PTY_i32
) {

1323 
s
.
x
.
u32
 = 
__but_z
(
0
.x.u32);

1326 
	gINTRN_C_ffs
:

1327 i(
ex
->
yp
 =
PTY_u32
 ||x->y=
PTY_i32
) {

1328 
s
.
x
.
u32
 = 
__but_ffs
(
0
.x.u32);

1331 
	gINTRN_C_v_4
:

1332 i(
ex
->
yp
 =
PTY_u32
 ||x->y=
PTY_i32
) {

1333 
s
.
x
.
u32
 = 
__but_bv32
(
0
.x.u32);

1339 
	g_ex
;

1343 
	gb_OP_dassign
:

1344 
b_OP_pssign
:

1345 
b_OP_maydassign
:

1346 
b_OP_ssign
:

1347 
b_OP_block
:

1348 
b_OP_do
:

1349 
b_OP_dowhe
:

1350 
b_OP_if
:

1351 
b_OP_whe
:

1352 
b_OP_swch
:

1353 
b_OP_muiway
:

1354 
b_OP_fܗchem
:

1355 
b_OP_commt
:

1356 
b_OP_ev
:

1357 
b_OP_
:

1358 
b_OP_lsge
:

1359 
b_OP_ls
:

1360 
b_OP_asge
:

1361 
b_OP_as
:

1362 
b_OP_as
:

1363 
b_OP_tuas
:

1364 
b_OP_assigs
:

1365 
b_OP_abt
:

1366 
b_OP_asnnu
:

1367 
b_OP_assigsnnu
:

1368 
b_OP_asnnu
:

1369 
b_OP_tuasnnu
:

1370 
b_OP_dad
:

1371 
b_OP_addrof
:

1372 
b_OP_ddrof
:

1373 
b_OP_sizeoy
:

1374 
b_OP_fldsdi
:

1375 
b_OP_y
:

1376 
b_OP_ssignoff
:

1377 
b_OP_ssignoff
:

1378 
b_OP_gassign
:

1379 
b_OP_go
:

1380 
b_OP_brl
:

1381 
b_OP_brue
:

1382 
b_OP_tu
:

1383 
b_OP_ngego
:

1384 
b_OP_
:

1385 
b_OP_vtu
:

1386 
b_OP_surass
:

1387 
b_OP_r
:

1388 
b_OP_cuom
:

1389 
b_OP_pymphic
:

1390 
b_OP_i
:

1391 
b_OP_ri
:

1392 
b_OP_vtui
:

1393 
b_OP_sic
:

1394 
b_OP_sicwhty
:

1395 
b_OP_xsic
:

1396 
b_OP_assigd
:

1397 
b_OP_vtuassigd
:

1398 
b_OP_surassassigd
:

1399 
b_OP_rassigd
:

1400 
b_OP_cuomassigd
:

1401 
b_OP_pymphicassigd
:

1402 
b_OP_iassigd
:

1403 
b_OP_riassigd
:

1404 
b_OP_vtuiassigd
:

1405 
b_OP_sicassigd
:

1406 
b_OP_sicwhtyassigd
:

1407 
b_OP_xsicassigd
:

1408 
b_OP_Κt
:

1409 
b_OP_Κssigd
:

1410 
b_OP_vtuΚt
:

1411 
b_OP_vtuΚssigd
:

1412 
b_OP_surassΚt
:

1413 
b_OP_surassΚssigd
:

1414 
b_OP_rΚt
:

1415 
b_OP_rΚssigd
:

1416 
b_OP_jry
:

1417 
b_OP_y
:

1418 
b_OP_ry
:

1419 
b_OP_throw
:

1420 
b_OP_jstch
:

1421 
b_OP_tch
:

1422 
b_OP_ptch
:

1423 
b_OP_fly
:

1424 
b_OP_nury
:

1425 
b_OP_dy
:

1426 
b_OP_
:

1427 
b_OP_d
:

1428 
b_OP_un
:

1429 
b_OP_dun
:

1430 
b_OP_gosub
:

1431 
b_OP_tsub
:

1432 
b_OP_syn
:

1433 
b_OP_synx
:

1434 
b_OP_deef
:

1435 
b_OP_ef
:

1436 
b_OP_deeet
:

1437 
b_OP_membacque
:

1438 
b_OP_memba
:

1439 
b_OP_membܖd
:

1440 
b_OP_membee
:

1441 
b_OP_b
:

1442 
b_OP_cڡr16
:

1443 
b_OP_
:

1444 
b_OP_o
:

1445 
b_OP_round
:

1446 
b_OP_unc
:

1447 
b_OP_c
:

1448 
b_OP_sq
:

1449 
b_OP_mloc
:

1450 
b_OP_gcmloc
:

1451 
b_OP_gmloc
:

1452 
b_OP_ackmloc
:

1453 
b_OP_gcmlocjy
:

1454 
b_OP_gmlocjy
:

1455 
b_OP_ackmlocjy
:

1456 
b_OP_sverfunc
:

1457 
b_OP_svevtufunc
:

1458 
b_OP_r
:

1459 
b_OP_CG_y_em_add
:

1460 
b_OP_cmp
:

1461 
b_OP_cm
:

1462 
b_OP_cmpg
:

1463 
b_OP_nd
:

1464 
b_OP_li
:

1465 
b_OP_nd
:

1466 
b_OP_ci
:

1467 
b_OP_sicwhty
:

1468 
b_OP_ssigcoff
:

1469 
b_OP_dpcoff
:

1470 
b_OP_checkpot
:

1471 
b_OP_addrofc
:

1472 
b_OP_igo
:

1473 
b_OP_asm
:

1474 
b_OP_dadoff
:

1475 
b_OP_dassignoff
:

1476 
b_OP_ssignoff
:

1477 
b_OP_blkassignoff
:

1478 
b_OP_iδo
:

1479 
b_OP_iδssigd
:

1481 
MASSERT
(
l
, "NIY");

1484 
	g_ex
:

1485  
s
;

	@lmbc/src/load_store.cpp

15 
	~"mvue.h
"

16 
	~"mfuni.h
"

17 
	~"mas.h
"

19 
mea
 
	gm
 {

21 
mld
(
ut8
* 
addr
, 
PrimTy
 
yp
, 
MVue
& 
s
, 
size_t
 
aggSize
) {

22 
	gs
.
	gyp
 = 
yp
;

23 
	gyp
) {

24 
	gPTY_i8
:

25 
s
.
x
.
i64
 = *(
t8
 *)
addr
;

27 
	gPTY_i16
:

28 
s
.
x
.
i64
 = *(
t16
 *)
addr
;

30 
	gPTY_i32
:

31 
s
.
x
.
i64
 = *(
t32
 *)
addr
;

33 
	gPTY_i64
:

34 
s
.
x
.
i64
 = *(
t64
 *)
addr
;

36 
	gPTY_u8
:

37 
s
.
x
.
u64
 = *(
ut8
 *)
addr
;

39 
	gPTY_u16
:

40 
s
.
x
.
u64
 = *(
ut16
 *)
addr
;

42 
	gPTY_u32
:

43 
s
.
x
.
u64
 = *(
ut32
 *)
addr
;

45 
	gPTY_u64
:

46 
s
.
x
.
u64
 = *(
ut64
 *)
addr
;

48 
	gPTY_f32
:

49 
s
.
x
.
f32
 = *(*)
addr
;

51 
	gPTY_f64
:

52 
s
.
x
.
f64
 = *(*)
addr
;

54 
	gPTY_a64
:

55 
s
.
x
.
a64
 = *(
ut8
 **)
addr
;

57 
	gPTY_agg
:

58 
s
.
x
.
a64
 = 
addr
;

59 
	gs
.
	gaggSize
 = 
aggSize
;

62 
MASSERT
(
l
, "mldty%d NYI", 
yp
);

67 
me
(
ut8
* 
addr
, 
PrimTy
 
yp
, 
MVue
& 
v
, 
bo
 
toVArgSck
) {

68 i(!
IsPrimiveIeg
(
yp
|| !IsPrimiveIeg(
v
.ptyp)) {

69 
MASSERT
(
yp
 =
v
.ptyp ||

70 
yp
 =
PTY_a64
 && 
v
.y=
PTY_u64
 ||

71 
yp
 =
PTY_u64
 && 
v
.y=
PTY_a64
,

72 "mܐty mismch: %dnd %d", 
yp
, 
v
.ptyp);

74 
	gyp
) {

75 
	gPTY_i8
:

76 *(
t8
 *)
addr
 = 
v
.
x
.
i8
;

78 
	gPTY_i16
:

79 *(
t16
 *)
addr
 = 
v
.
x
.
i16
;

81 
	gPTY_i32
:

82 *(
t32
 *)
addr
 = 
v
.
x
.
i32
;

84 
	gPTY_i64
:

85 *(
t64
 *)
addr
 = 
v
.
x
.
i64
;

87 
	gPTY_u8
:

88 *(
ut8
 *)
addr
 = 
v
.
x
.
u8
;

90 
	gPTY_u16
:

91 *(
ut16
 *)
addr
 = 
v
.
x
.
u16
;

93 
	gPTY_u32
:

94 *(
ut32
 *)
addr
 = 
v
.
x
.
u32
;

96 
	gPTY_u64
:

97 *(
ut64
 *)
addr
 = 
v
.
x
.
u64
;

99 
	gPTY_f32
:

100 *(*)
addr
 = 
v
.
x
.
f32
;

102 
	gPTY_f64
:

103 *(*)
addr
 = 
v
.
x
.
f64
;

105 
	gPTY_a64
:

106 *(
ut8
 **)
addr
 = 
v
.
x
.
a64
;

108 
	gPTY_agg
:

109 i(
toVArgSck
) {

110 i(
v
.
aggSize
 > 16) {

111 *(
ut8
 **)
addr
 = 
v
.
x
.
a64
;

113 
memy
(
addr
, 
v
.
x
.
a64
, v.
aggSize
);

117 
MASSERT
(
v
.
aggSize
 <= 16, "mstoregg > 16");

118 
memy
(
addr
, &(
v
.
x
.
u64
), v.
aggSize
);

122 
MASSERT
(
l
, "mܐy%d NYI", 
yp
);

	@lmbc/src/mfunction.cpp

16 
	~<ffi.h
>

17 
	~<crg
>

19 
	~<unid.h
>

20 
	~<sys/sys.h
>

21 
	#gtid
(
	`sys
(
SYS_gtid
)

	)

22 
	~<sys/mm.h
>

23 
	~<cmh
>

25 
	~"mfuni.h
"

26 
	~"mimty.h
"

27 
	~"mas.h
"

29 
mea
 
	gm
 {

31 
	gMFuni
::
MFuni
(
LmbcFunc
 *
funcInfo
,

32 
MFuni
 *
funcCr
,

33 
ut8
 *
autoVs
,

34 
MVue
 *
egs
,

35 
MVue
 *
fmvs
) :

36 
fo
(
funcInfo
),

37 
Δ
(
funcCr
),

38 
ame
(
autoVs
),

39 
pRegs
(
egs
),

40 
fmVs
(
fmvs
),

41 
Args
(
nuαr
),

42 
aggrArgsBuf
(
nuαr
)

44 
	gnumClArgs
 = 0;

45 
	gxtStmt
 = 
fo
->
mFunc
->
GBody
();

46 
	g
 = (
ut8
*)
ame
 + 
fo
->
ameSize
;

47 
	gloOfft
 = 0;

48 
	gloMem
 = 
nuαr
;

51 
	gMFuni
::~
MFuni
() { }

53 
ut8
 *
MFuni
::
Ao
(
ut32
 
sz
) {

54 i(
loOfft
 + 
sz
 > 
ALLOCA_MEMMAX
) {

55  
nuαr
;

57 
ut8
 *
	gr
 = 
loMem
 + 
loOfft
;

58 
	gloOfft
 +
sz
;

59  
	gr
;

62 
ut8
 *
	gMFuni
::
GFmVAddr
(
StIdx
 
idx
) {

63 aut

 = 
fo
->
idx2Pm
.
fd
(
idx
.
FuIdx
());

64 i(
	g
 =
fo
->
idx2Pm
.
d
()) {

65  
nuαr
;

67 i(
	g
->
	gcd
->
	gyp
 =
PTY_agg
) {

68 
MASSERT
(
Δ
->
aggrArgsBuf
, "aggrArgsBufot init");

69  
	gΔ
->
	gaggrArgsBuf
 + 
	g
->
	gcd
->
	geIdx
;

71 ((
	gut8
*)&
	gfmVs
[

->
cd
->
eIdx
].
	gx
);

74 
bo
 
IsExtFunc
(
PUIdx
 
puIdx
, 
LmbcMod
& 
modu
) {

75 
MIRFuni
 *
	gfunc
 = 
GlobTabs
::
GFuniTab
().
GFuniFromPuidx
(
puIdx
);

76 i(
	gfunc
->
IsEx
() ||

77 
	gfunc
->
GAr
(
FUNCATTR_imic
) ||

78 !
	gfunc
->
GBody
() ||

79 (
	gfunc
->
IsWk
(&& 
	gmodu
.
FdExtFunc
(
puIdx
))) {

80  
	gue
;

82  
	gl
;

86 
size_t
 
GIRdAggrSize
(
BaNode
* 
ex
) {

87 
MASSERT
(
ex
->

 =
OP_d
 &&x->
yp
 =
PTY_agg
, "iread onon PTY_aggype");

88 
IadNode
 *
	gd
 = 
ic_
<IadNode*>(
ex
);

89 
TyIdx
 
	grTyIdx
 = 
d
->
GTyIdx
();

90 
MIRPTy
 *
	grTy
 =

91 
ic_
<
MIRPTy
*>(
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
rTyIdx
));

92 
MIRTy
 *
	gaggTy
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
rTy
->
GPodTyIdx
());

93 
FldID
 
	gfd
 = 
d
->
GFldID
();

94 
size_t
 
	gsz
 = 
aggTy
->
GSize
();

95 i(
	gfd
 != 0) {

96 
MIRSuTy
 *
ruTy
 = 
ic_
<MIRSuTy*>(
aggTy
);

97 
MIRTy
 *
	gfdTy
 = 
ruTy
->
GFldTy
(
fd
);

98 
ut32
 
	gfdOfft
 = 
ruTy
->
GBOfftFromBaAddr
(
fd
);

99 
	gsz
 = 
fdTy
->
GSize
();

100 ()
	gfdOfft
;

102  ((
	gsz
 + 7) >> 3) << 3;

107 
size_t
 
GAggClArgsSize
(
LmbcFunc
 *
Γ
, 
ClNode
 *

) {

108 
size_t
 
	gtٮAggClArgsSize
 = 
Γ
->
fmsAggSize
;

109 i(
	gΓ
->
	gisVArgs
) {

110 
	gi
 = 
Γ
->
fmsNum
; i < 
	g
->
NumOds
(); i++) {

111 i(
	g
->
Od
(
i
)->
	gyp
 =
PTY_agg
) {

112 
MASSERT
(

->
Od
(
i
)->

 =
OP_d
, "agg varrg unexpected op");

113 
	gtٮAggClArgsSize
 +
GIRdAggrSize
(

->
Od
(
i
));

117  
	gtٮAggClArgsSize
;

135 
	gMFuni
::
ClMFuncDe
(
ClNode
 *

) {

136 
LmbcFunc
 *
Γ
 = 
fo
->
lmbcMod
->
LkupLmbcFunc
(

->
GPUIdx
());

137 i(!
	gΓ
->
	gfmsNum
) {

138 
InvokeFunc
(
Γ
, 
this
);

142 
size_t
 
	gtٮAggClArgsSize
 = 
GAggClArgsSize
(
Γ
, 

);

143 
	gaggrArgsBuf
 = 
ic_
<
ut8
*>(
lo
(
tٮAggClArgsSize
));

144 
	gi
 = 0, 
	gsz
 = 0, 
	gofft
 = 
Γ
->
fmsAggSize
; i < 
	g
->
NumOds
(); i++) {

146 i(
	g
->
Od
(
i
)->
	gyp
 !
PTY_agg
) {

147 
Args
[
i
] = 
EvEx
(*
this
, 

->
Od
(i));

151 i(
	gi
 < 
	gΓ
->
	gfmsNum
) {

152 
	gArgs
[
i
] = 
EvEx
(*
this
, 

->
Od
(i), 
Γ
->
pos2Pm
[i]);

156 
	gsz
 = 
GIRdAggrSize
(

->
Od
(
i
));

157 
PmInf
 
rmInf
(
PTY_agg
, 
sz
, 
l
, 
offt
);

158 
	gofft
 +
sz
;

159 
	gArgs
[
i
] = 
EvEx
(*
this
, 

->
Od
(i), &
rmInf
);

161 i(
	gΓ
->
	gisVArgs
) {

162 
ClVaArgFunc
(

->
NumOds
(), 
Γ
);

164 
InvokeFunc
(
Γ
, 
this
);

168 
	gMFuni
::
ClMFuncInde
(
INode
 *
i
, 
LmbcFunc
 *
Info
) {

169 i(!
	gInfo
->
	gfmsNum
) {

170 
InvokeFunc
(
Info
, 
this
);

175 
	gaggrArgsBuf
 = 
ic_
<
ut8
*>(
lo
(
Info
->
fmsAggSize
));

176 
	gi
=0; i < 
	gi
->
NumOds
()-1; i++) {

177 
	gArgs
[
i
] = (
i
->
Od
(i+1)->
yp
 =
PTY_agg
) ?

178 
EvEx
(*
this
, 
i
->
Od
(
i
+1), 
Info
->
pos2Pm
[i]) :

179 
EvEx
(*
this
, 
i
->
Od
(
i
+1));

181 i(
	gInfo
->
	gisVArgs
) {

182 
ClVaArgFunc
(
i
->
NumOds
()-1, 
Info
);

184 
InvokeFunc
(
Info
, 
this
);

199 
	gMFuni
::
ClVaArgFunc
(
numArgs
, 
LmbcFunc
 *
Info
) {

200 
ut32
 
	gvArgsSz
 = 0;

201 
	gi
 = 
Info
->
fmsNum
; i < 
	gnumArgs
; ++i) {

202 i(
	gArgs
[
i
].
	gyp
 !
PTY_agg
 || 
Args
[i].
aggSize
 > 16 ) {

203 
vArgsSz
 += 8;

205 
	gvArgsSz
 +
Args
[
i
].
aggSize
;

208 
	gvaArgsSize
 = 
vArgsSz
;

209 
	gvaArgs
 = 
ic_
<
ut8
*>(
lo
(
vaArgsSize
));

210 
	gi
 = 
Info
->
fmsNum
, 
	gofft
 = 0; i < 
	gnumArgs
; ++i) {

211 
me
(
vaArgs
 + 
offt
, 
Args
[
i
].
yp
, clArgs[i], 
ue
);

212 i(
	gArgs
[
i
].
	gyp
 !
PTY_agg
 || 
Args
[i].
aggSize
 > 16 ) {

213 
offt
 += 8;

215 
	gofft
 +
Args
[
i
].
aggSize
;

218 
InvokeFunc
(
Info
, 
this
);

221 
	gMFuni
::
ClExtFuncDe
(
ClNode
* 

) {

222 
MIRFuni
 *
func
 = 
GlobTabs
::
GFuniTab
().
GFuniFromPuidx
(

->
GPUIdx
());

223 
	gMVe
<
	gFmDef
> &
	gfmDefVec
 = 
func
->
GFmDefVec
();

224 
	gFuncAddr
& 
	gddr
 = *
fo
->
lmbcMod
->
GFuncAddr
(

->
GPUIdx
());

225 
ffi__t
 
	g
 = (ffi__t)(
ddr
.
funcP
.
tiveFunc
);

226 
MASSERT
(

, "External functionot found");

228 
	gi
 = 
fmDefVec
.
size
(); i < 
	g
->
NumOds
(); i++) {

229 i(
	g
->
Od
(
i
)->
	gyp
 =
PTY_agg
) {

231 
MASSERT
(
l
, "extern func: va-arg ofggype NYI");

235 
	gaggrArgsBuf
 = 
ic_
<
ut8
*>(
lo
(
ddr
.
fmsAggSize
));

236 
	gi
 = 0, 
	gofft
 = 0; i < 
	g
->
NumOds
(); i++) {

238 i(
	g
->
Od
(
i
)->
	gyp
 !
PTY_agg
) {

239 
Args
[
i
] = 
EvEx
(*
this
, 

->
Od
(i));

243 i(
	gi
 < 
	gfmDefVec
.
size
()) {

244 
MIRTy
* 
	gty
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
fmDefVec
[
i
].
fmTyIdx
);

245 
MASSERT
(
ty
->
GPrimTy
(=
PTY_agg
, "expects formalrg ofggype");

246 
PmInf
 
rmInf
(
PTY_agg
, 
ty
->
GSize
(), 
l
, 
offt
);

247 
	gofft
 +
ty
->
GSize
();

248 
	gArgs
[
i
] = 
EvEx
(*
this
, 

->
Od
(i), &
rmInf
);

253 
ClWhFFI
(
func
->
GRuTy
()->
GPrimTy
(), 

);

256 
	gMFuni
::
ClExtFuncInde
(
INode
 *
iδo
, * 

) {

258 
	gi
=0; i < 
	giδo
->
NumOds
()-1; i++) {

259 
	gArgs
[
i
]
EvEx
(*
this
, 
iδo
->
Od
(i+1));

261 
MIRTy
 *
	gty
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
iδo
->
GRTyIdx
());

262 
MIRFuncTy
 *
	gfPro
 = 
ic_
<MIRFuncTy*>(
ty
);

263 
MIRTy
 *
	gfRTy
 = 
GlobTabs
::
GTyTab
().
GTyFromTyIdx
(
fPro
->
GRTyIdx
());

264 
ClWhFFI
(
fRTy
->
GPrimTy
(), (
ffi__t
)

);

267 
	gMFuni
::
ClIrsic
(
IrsicNode
 &
n
) {

268 
MIRIrsicID
 
Id
 = 
n
.
GIrsic
();

269 
	gId
) {

270 
	gINTRN_C_va_t
: {

271 
MVue
 
addrofAP
 = 
EvEx
(*
this
, 
n
.
Od
(0));

273 
VaLi
 *
	gvaLi
 = (
m
::VaLi*)
addrofAP
.
x
.
a64
;

274 
	gvaLi
->
	ggr_offs
 = 0;

275 
	gvaLi
->
	gack
 = 
Δ
->
vaArgs
;

279 
MASSERT
(
l
, "ClIrsi%d\NYI", 
Id
);

285 
ffi_ty
 
	gffi_ty_b
[] = {

286 
ffi_ty_void
,

287 
	#EXPANDFFI1
(
x
x,

	)

288 
	#EXPANDFFI2
(
x

	`EXPANDFFI1
(x)

	)

289 
	#PRIMTYPE
(
P

	`EXPANDFFI2
(
FFITYPE_
##P)

	)

290 
	#LOAD_ALGO_PRIMARY_TYPE


	)

291 
	~"im_tys.def
"

292 #unde
PRIMTYPE


293 
ffi_ty_void


297 
ffi_ty
 *
	gvaLiObjAch64
 [] = {

298 
ffi_ty_b
 + 
PTY_r
,

299 
ffi_ty_b
 + 
PTY_r
,

300 
ffi_ty_b
 + 
PTY_r
,

301 
ffi_ty_b
 + 
PTY_i32
,

302 
ffi_ty_b
 + 
PTY_i32
,

303 
nuαr


307 
ffi_ty
 *
	gvaLiObjX86_64
 [] = {

308 
ffi_ty_b
 + 
PTY_u32
,

309 
ffi_ty_b
 + 
PTY_u32
,

310 
ffi_ty_b
 + 
PTY_r
,

311 
ffi_ty_b
 + 
PTY_r
,

312 
nuαr


316 
ffi_ty
 
	gvaLi_ffi_ty
 = { 0, 0, 
FFI_TYPE_STRUCT
, 
vaLiObjAch64
 };

326 
	gMFuni
::
ClWhFFI
(
PrimTy
 
t_yp
, 
ffi__t
 

) {

327 
ffi_cif
 
	gcif
;

328 
ffi_ty
 
	gffi_t_ty
 = 
ffi_ty_b
[
t_yp
];

329 
ffi_ty
* 
	gg_tys
[
numClArgs
];

330 * 
	ggs
[
numClArgs
];

333 
	gi
=0; i < 
	gnumClArgs
; ++i) {

334 
	ggs
[
i
] = &
Args
[i].
x
;

335 i(
	gArgs
[
i
].
	gyp
 =
PTY_agg
) {

336 
g_tys
[
i
] = &
vaLi_ffi_ty
;

338 
	gg_tys
[
i
] = 
ffi_ty_b
 + 
Args
[i].
yp
;

342 
ffi_us
 
	gus
 = 
ffi__cif
(&
cif
, 
FFI_DEFAULT_ABI
, 
numClArgs
, &
ffi_t_ty
, 
g_tys
);

343 if(
	gus
 =
FFI_OK
) {

344 
ffi_
(&
cif
, 

, &
tV0
.
x
, 
gs
);

345 
	gtV0
.
	gyp
 = 
t_yp
;

347 
MIR_FATAL
("Faed mhod%p", (*)

);

	@lmbc/src/mplsh.cpp

15 
	~<gnu/lib-mes.h
>

16 
	~"mas.h
"

17 
	~"lmbc_g.h
"

18 
	~"g_shim.h
"

20 
mea
 
	gm
 {

22 *
	gLmbcMod
::
FdExtFunc
(
PUIdx
 
puidx
) {

23 * 

 = 
extFuncM
[
puidx
];

24 i(
	g
) {

25  
	g
;

27 
	gd
::
rg
 
ame
 = 
GlobTabs
::
GFuniTab
().
GFuniFromPuidx
(
puidx
)->
GName
();

28 aut
	g
 : 
libHds
) {

29 

 = 
dlsym
(

, 
ame
.
c_r
());

30 i(
	g
) {

34 
MASSERT
(

, "dlsym symbނ found: %s", 
ame
.
c_r
());

35 
	gextFuncM
[
puidx
] = 

;

36 (
	g
);

39 *
	gLmbcMod
::
FdExtSym
(
StIdx
 
idx
) {

40 * 
v
 = 
extSymM
[
idx
.
FuIdx
()];

41 i(
	gv
) {

42  
	gv
;

44 
MIRSymb
* 
	gsym
 = 
GlobTabs
::
GGsymTab
().
GSymbFromStidx
(
idx
.
Idx
());

45 i(
	gsym
) {

46 aut
	g
 : 
libHds
) {

47 
v
 = 
dlsym
(

, 
sym
->
GName
().
c_r
());

48 i(
	gv
) {

52 
MASSERT
(
v
, "dlsym ExtSym found: %s", 
sym
->
GName
().
c_r
());

53 
	gextSymM
[
idx
.
FuIdx
()] = 
v
;

55 
MASSERT
(
sym
, "Unableo find symbol");

56 (
	gv
);

59 
	gm
::
MIRModu
*

60 
LmbcMod
::
Impt
(
d
::
rg
 
th
) {

61 
m
::
MIRModu
* 
mod
 = 
w
 m::MIRModu(
th
.
c_r
());

62 
	gmod
->
SSrcLg
(
kSrcLgC
);

63 
	gd
::
rg
::
size_ty
 
ϡd
 = 
mod
->
GFeName
().
fd_ϡ_of
(".");

64 
bo
 
	gimbc
 = 
ϡd
 !
d
::
rg
::
os
 && 
mod
->
GFeName
().
com
(lastdot, 5, ".lmbc\0") == 0;

65 i(!
	gimbc
) {

66 
ERR
(
kLncE
, "Iumu b.lmbfe: %s", 
th
.
c_r
());

67 
de
 
	gmod
;

68  
	gnuαr
;

71 
ByMImpt
 
bMt
(*
mod
);

72 
	gbMt
.
SImp܋d
(
l
);

73 
	gd
::
rg
 
modid
 = 
mod
->
GFeName
();

74 i(!
	gbMt
.
Impt
(
modid
, 
ue
)) {

75 
ERR
(
kLncE
, "msh-lmbc: cn o.lmbfe: %s", 
modid
.
c_r
());

76 
de
 
	gmod
;

77  
	gnuαr
;

79  
	gmod
;

84 
	gd
::
ve
<
d
::
rg
> 
eLdLibs
 = {

85 
LIBC_SO
,

86 
LIBM_SO


89 
	gLmbcMod
::
LdDefLibs
() {

90 aut

 : 
eLdLibs
) {

91 *
hd
 = 
dlݒ
(

.
c_r
(), 
RTLD_NOW
 | 
RTLD_GLOBAL
 | 
RTLD_NODELETE
);

92 
MASSERT
(
hd
, "dlݒ %ed", 

.
c_r
());

93 
	glibHds
.
push_back
(
hd
);

97 
	gLmbcMod
::
LmbcMod
(* 
th
: 
lmbcPh
(path) {

98 
LdDefLibs
();

99 
	gmMod
 = 
Impt
(
th
);

100 
	gglobSticMemSize
 = 
mMod
->
GGlobMemSize
();

104 
RunLmbc
(
gc
, ** 
gv
) {

105 
	grc
 = 1;

106 cڡ 
	gskArgsNum
 = 1;

107 
LmbcMod
* 
	gmod
 = 
w
 LmbcMod(
gv
[
skArgsNum
]);

108 
ASSERT
(
mod
, "Create Lmbc module failed");

109 
ASSERT
(
mod
->
mMod
, "Import Lmbc module failed");

110 
	gmod
->
InModu
();

111 i(
	gmod
->
	gmaFn
) {

112 
	grc
 = 
__geShim
(
mod
->
maFn
, 
gc
-
skArgsNum
, 
gv
+skipArgsNum);

114  
	grc
;

120 
	$ma
(
gc
, **
gv
) {

121 i(
gc
 == 1) {

122 
d
::
rg
 
	`th
(
gv
[0]);

123 ()
	`MIR_PRINTF
("uge: %<fe>.lmbc\n", 
th
.
	`subr
թh.
	`fd_ϡ_of
("/\\"+ 1).
	`c_r
());

124 
	`ex
(1);

126  
m
::
	`RunLmbc
(
gc
, 
gv
);

127 
	}
}

	@
1
.
0
13
303
lmbc/include/eng_shim.h
lmbc/include/lmbc_eng.h
lmbc/include/massert.h
lmbc/include/mexpression.h
lmbc/include/mfunction.h
lmbc/include/mprimtype.h
lmbc/include/mvalue.h
lmbc/src/eng_shim.cpp
lmbc/src/init.cpp
lmbc/src/invoke_method.cpp
lmbc/src/load_store.cpp
lmbc/src/mfunction.cpp
lmbc/src/mplsh.cpp
