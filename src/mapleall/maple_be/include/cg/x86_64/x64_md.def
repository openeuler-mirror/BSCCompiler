/*
 * Copyright (c) [2022] Huawei Technologies Co.,Ltd.All rights reserved.
 *
 * OpenArkCompiler is licensed under the Mulan PSL v1.
 * You can use this software according to the terms and conditions of the Mulan PSL v1.
 * You may obtain a copy of Mulan PSL v1 at:
 *
 *     http://license.coscl.org.cn/MulanPSL
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
 * FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v1 for more details.
 */
/* {mop, opnds, prop, latency, name, format, length} */
/* begin machine operation code of X86_64 instruction , */
DEFINE_MOP(MOP_begin, {},0,0,"","",0)

/* # Definitions
 * use x64 style b/w/l/q for 8b/16b/32b/64b operation
 * and using AT&T style assembly
 */

/* X64 MOVES */
// TODO: fix intruction opnds, prop, latency, format and length
// TODO: the encoding and enumeration seems too verbose
// TODO: understand how other system represent these MOPs (especially for x86-64)
// TODO: this is still an experiment
// TODO: should make sure the convention is consistent with (AT&T style?)
// TODO: how the general Machine instruction is designed?

DEFINE_MOP(MOP_movl_i_r, {&OpndDescription::Imm32,&OpndDescription::Reg32ID},ISMOVE,kLtAlu,"movl","0,1",1)
DEFINE_MOP(MOP_movl_r_r, {&OpndDescription::Reg32IS,&OpndDescription::Reg32ID},ISMOVE,kLtAlu,"movl","0,1",1)
DEFINE_MOP(MOP_movq_i_r, {&OpndDescription::Imm64,&OpndDescription::Reg64ID},ISMOVE,kLtAlu,"movq","0,1",1)
DEFINE_MOP(MOP_movq_r_r, {&OpndDescription::Reg64IS,&OpndDescription::Reg64ID},ISMOVE,kLtAlu,"movq","0,1",1)

DEFINE_MOP(MOP_movb_i_m, {&OpndDescription::Imm8,&OpndDescription::Mem8D},0,kLtAlu,"movb","0,1",1)
DEFINE_MOP(MOP_movl_i_m, {&OpndDescription::Imm32,&OpndDescription::Mem32D},0,kLtAlu,"movl","0,1",1)
DEFINE_MOP(MOP_movq_i_m, {&OpndDescription::Imm64,&OpndDescription::Mem64D},0,kLtAlu,"movq","0,1",1)
/* move byte loaded from mem and zero extend to 32  bit*/
DEFINE_MOP(MOP_movzbl_m_r, {&OpndDescription::Mem8S,&OpndDescription::Reg32ID},0,kLtAlu,"movzbl","0,1",1)

/* move 32 bits register and signed extend to 64 bit */
DEFINE_MOP(MOP_movslq_r_r, {&OpndDescription::Reg32IS,&OpndDescription::Reg64ID},0,kLtAlu,"movslq","0,1",1)

DEFINE_MOP(MOP_movl_r_m, {&OpndDescription::Reg32IS,&OpndDescription::Mem32D},ISSTORE,kLtAlu,"movl","0,1",1)
DEFINE_MOP(MOP_movq_r_m, {&OpndDescription::Reg64IS,&OpndDescription::Mem64D},ISSTORE,kLtAlu,"movq","0,1",1)
DEFINE_MOP(MOP_movl_m_r, {&OpndDescription::Mem32S,&OpndDescription::Reg32ID},ISLOAD,kLtAlu,"movl","0,1",1)
DEFINE_MOP(MOP_movq_m_r, {&OpndDescription::Mem64S,&OpndDescription::Reg64ID},ISLOAD,kLtAlu,"movq","0,1",1)

/* add */
DEFINE_MOP(MOP_addl_r_r, {&OpndDescription::Reg32IS,&OpndDescription::Reg32IDS},0,kLtAlu,"addl","0,1",1)
DEFINE_MOP(MOP_addq_i_r, {&OpndDescription::Imm32,&OpndDescription::Reg64IDS},0,kLtAlu,"addq","0,1",1)
DEFINE_MOP(MOP_addq_r_r, {&OpndDescription::Reg64IS,&OpndDescription::Reg64IDS},0,kLtAlu,"addq","0,1",1)

DEFINE_MOP(MOP_movabs_i_r, {&OpndDescription::Imm64,&OpndDescription::Reg64ID},0,kLtAlu,"movabs","0,1",1)
//The movabs instruction to load arbitrary 64-bit constant into register and to load/store integer register from/to arbitrary constant 64-bit address is available

/* push & pop & lea */
DEFINE_MOP(MOP_pushq_r, {&OpndDescription::Reg32IS},0,kLtAlu,"pushq","0,1",1)
DEFINE_MOP(MOP_popq_r, {&OpndDescription::Reg32IS},0,kLtAlu,"popq","0,1",1)

DEFINE_MOP(MOP_leaq_m_r, {&OpndDescription::Mem64S,&OpndDescription::Reg64ID},0,kLtAlu,"leaq","0,1",1)
DEFINE_MOP(MOP_leal_m_r, {&OpndDescription::Mem32S,&OpndDescription::Reg32ID},0,kLtAlu,"leal","0,1",1)
DEFINE_MOP(MOP_leaw_m_r, {&OpndDescription::Mem16S,&OpndDescription::Reg16ID},0,kLtAlu,"leaw","0,1",1)

/* sub & sbb */
DEFINE_MOP(MOP_subq_i_r, {&OpndDescription::Imm32, &OpndDescription::Reg64ID},0,kLtAlu,"subq","0,1",1)
DEFINE_MOP(MOP_sbbq_r_r, {&OpndDescription::Reg64IS, &OpndDescription::Reg64IDS},0,kLtAlu,"sbbq","0,1",1)

/* and, or, xor, not, neg */
DEFINE_MOP(MOP_andl_r_r, {&OpndDescription::Reg32IS, &OpndDescription::Reg32IDS},0,kLtAlu,"andl","0,1",1)

DEFINE_MOP(MOP_notw_r, {&OpndDescription::Reg16IDS},0,kLtAlu,"notw","0,1",1)
DEFINE_MOP(MOP_notl_r, {&OpndDescription::Reg32IDS},0,kLtAlu,"notl","0,1",1)

DEFINE_MOP(MOP_negw_r, {&OpndDescription::Reg16IDS},0,kLtAlu,"negw","0,1",1)
DEFINE_MOP(MOP_negl_r, {&OpndDescription::Reg32IDS},0,kLtAlu,"negl","0,1",1)

/* shl, shr */
DEFINE_MOP(MOP_shlq_i_r, {&OpndDescription::Imm8, &OpndDescription::Reg64IDS},0,kLtAlu,"shlq","0,1",1)
DEFINE_MOP(MOP_shrq_i_r, {&OpndDescription::Imm8, &OpndDescription::Reg64IDS},0,kLtAlu,"shrq","0,1",1)
DEFINE_MOP(MOP_sarq_i_r, {&OpndDescription::Imm8, &OpndDescription::Reg64IDS},0,kLtAlu,"sarq","0,1",1)

/* jmp, je, jne */
DEFINE_MOP(MOP_jmpq_m, {&OpndDescription::Mem64S},0,kLtAlu,"jmpq","0",1)
DEFINE_MOP(MOP_jmpq_l, {&OpndDescription::Lbl64},0,kLtAlu,"jmpq","0",1) // ip relative

DEFINE_MOP(MOP_je_l, {&OpndDescription::Lbl64},0,kLtAlu,"je","0",1)
DEFINE_MOP(MOP_ja_l, {&OpndDescription::Lbl64},0,kLtAlu,"ja","0",1)  // unsigned >
DEFINE_MOP(MOP_jae_l, {&OpndDescription::Lbl64},0,kLtAlu,"jae","0",1) // unsigned >=
DEFINE_MOP(MOP_jne_l, {&OpndDescription::Lbl64},0,kLtAlu,"jne","0",1)
DEFINE_MOP(MOP_jb_l, {&OpndDescription::Lbl64},0,kLtAlu,"jb","0",1)  // unsigned <
DEFINE_MOP(MOP_jbe_l, {&OpndDescription::Lbl64},0,kLtAlu,"jbe","0",1) // unsigned <=
DEFINE_MOP(MOP_jl_l, {&OpndDescription::Lbl64},0,kLtAlu,"jl","0",1)  // signed <
DEFINE_MOP(MOP_jle_l, {&OpndDescription::Lbl64},0,kLtAlu,"jle","0",1) // signed <=

/* cmp, test */
DEFINE_MOP(MOP_cmpq_r_r, {&OpndDescription::Reg64IS, &OpndDescription::Reg64IS},0,kLtAlu,"cmpq","0,1",1)
DEFINE_MOP(MOP_cmpq_i_q, {&OpndDescription::Imm32,&OpndDescription::Mem64S},0,kLtAlu,"cmpq","0,1",1)
DEFINE_MOP(MOP_cmpl_i_l, {&OpndDescription::Imm32,&OpndDescription::Mem32S},0,kLtAlu,"cmpl","0,1",1)
DEFINE_MOP(MOP_testq_r_r, {&OpndDescription::Reg64IS, &OpndDescription::Reg64IS},0,kLtAlu,"testq","0,1",1)

/* set */
DEFINE_MOP(MOP_sete_r, {&OpndDescription::Reg64ID},0,kLtAlu,"sete","0,1",1)
DEFINE_MOP(MOP_setb_r, {&OpndDescription::Reg64ID},0,kLtAlu,"setb","0,1",1)
DEFINE_MOP(MOP_setb_m, {&OpndDescription::Mem8D},0,kLtAlu,"setb","0,1",1)
DEFINE_MOP(MOP_setbe_r, {&OpndDescription::Reg64ID},0,kLtAlu,"setbe","0,1",1)
DEFINE_MOP(MOP_seta_r, {&OpndDescription::Reg64ID},0,kLtAlu,"seta","0,1",1)
DEFINE_MOP(MOP_setl_r, {&OpndDescription::Reg64ID},0,kLtAlu,"setl","0,1",1)
DEFINE_MOP(MOP_setl_m, {&OpndDescription::Mem8D},0,kLtAlu,"setl","0,1",1)
DEFINE_MOP(MOP_setle_r, {&OpndDescription::Reg64ID},0,kLtAlu,"setle","0,1",1)
DEFINE_MOP(MOP_setne_r, {&OpndDescription::Reg64ID},0,kLtAlu,"setne","0,1",1)

/* cmov */
/* condition move below */
DEFINE_MOP(MOP_cmovbe_r_r, {&OpndDescription::Reg32IS,&OpndDescription::Reg32ID},0,kLtAlu,"cmovbe","0,1",1)
/* condition move equal */
DEFINE_MOP(MOP_cmoveq_r_r, {&OpndDescription::Reg64IS,&OpndDescription::Reg64ID},0,kLtAlu,"cmoveq","0,1",1)
/* condition move not equal */
DEFINE_MOP(MOP_cmovneq_r_r, {&OpndDescription::Reg64IS,&OpndDescription::Reg64ID},0,kLtAlu,"cmovneq","0,1",1)

/* call, ret */
DEFINE_MOP(MOP_callq_i, {&OpndDescription::Lbl64},ISCALL,kLtAlu,"callq","0",1)
DEFINE_MOP(MOP_callq_m, {&OpndDescription::Lbl64},ISCALL,kLtAlu,"callq","0",1)

DEFINE_MOP(MOP_retq, {},CANTHROW,kLtBranch,"ret","",1)

/* nop */
// TODO: still not clear why we need so many forms of nop (except for patch)
DEFINE_MOP(MOP_nopb, {&OpndDescription::Mem8S},0,kLtAlu,"nopb","",1)
DEFINE_MOP(MOP_nopw, {&OpndDescription::Mem16S},0,kLtAlu,"nopw","",1)
DEFINE_MOP(MOP_nopl, {&OpndDescription::Mem32S},0,kLtAlu,"nopl","",1)
DEFINE_MOP(MOP_nop, {},0,0,"nop","",1)
/* end of X64 instructions */
